<div class="row wrapper border-bottom white-bg page-heading">
    <div class="col-lg-10">
        <h2>Additional Information</h2>
        <ol class="breadcrumb">
            <li>
                <a href="index.html">Home</a>
            </li>
            <li>
                <a>Labs</a>
            </li>
            <li>
                MediaSDK Sample
            </li>
            <li class="active">
                <strong>Video Decoder</strong>
            </li>
        </ol>
    </div>
</div>

<div class="wrapper wrapper-content animated fadeInRight" ng-controller="CodeEditorCtrl">
    <div class="row">
        <div class="col-lg-12">
            <div ibox title="Video Decoding Sample">
                <div content-block name="xdk-issues" message="Check after completing this section">
                  <p>Console application which performs decoding of elementary compressed video stream to raw frames. Includes the following features:
                    <ul>
                      <li>stereoscopic 3D (S3D) rendering of elementary MVC (Multi-View Video Coding) streams</li>
                      <li>decoding of HEVC (High Efficiency Video Coding) video via HEVC Decoder</li>
                      <li>decoding with video post processing (color conversion) of raw video sequences</li>
                  </ul>
                  <p> Create a new c++ file named pipeline_decoding.cpp with the code from following sections</p>
                </div>
            </div>
        </div>
    </div>

    <div class="row">
        <div class="col-lg-12">
            <div ibox title="Header files for inclusion">
                <div content-block name="xdk-issues" message="Check after completing this section">
                  <ui-codemirror ui-codemirror-opts="editorOptions" id="topic-configure">
                  #include "mfx_samples_config.h"
                  #include "sample_defs.h"
                  #include &ltalgorithm&gt

                  #if defined(_WIN32) || defined(_WIN64)
                  #include &lttchar.h&gt
                  #include &ltwindows.h&gt
                  #endif

                  #include &ltctime&gt
                  #include &ltalgorithm&gt
                  #include "pipeline_decode.h"
                  #include "sysmem_allocator.h"

                  #if defined(_WIN32) || defined(_WIN64)
                  #include "d3d_allocator.h"
                  #include "d3d11_allocator.h"
                  #include "d3d_device.h"
                  #include "d3d11_device.h"
                  #endif

                  #if defined LIBVA_SUPPORT
                  #include "vaapi_allocator.h"
                  #include "vaapi_device.h"
                  #include "vaapi_utils.h"
                  #endif

                  #if defined(LIBVA_WAYLAND_SUPPORT)
                  #include "class_wayland.h"
                  #endif

                  #pragma warning(disable : 4100)

                  #define __SYNC_WA // avoid sync issue on Media SDK side
                </ui-codemirror>

              </div>
            </div>
        </div>
    </div>

    <div class="row">
        <div class="col-lg-12">
            <div ibox title=" Constructor and Destructor for Decoding Pipeline">
                <div content-block name="xdk-issues" message="Check after completing this section">
                    <ui-codemirror ui-codemirror-opts="editorOptions" id="topic-configure">
                      CDecodingPipeline::CDecodingPipeline()
                      {
                          m_nFrames=0;
                          m_export_mode=0;
                          m_bVppFullColorRange=false;
                          m_bVppIsUsed = false;
                          MSDK_ZERO_MEMORY(m_mfxBS);

                          m_pmfxDEC = NULL;
                          m_pmfxVPP = NULL;
                          m_impl = 0;

                          MSDK_ZERO_MEMORY(m_mfxVideoParams);
                          MSDK_ZERO_MEMORY(m_mfxVppVideoParams);

                          m_pGeneralAllocator = NULL;
                          m_pmfxAllocatorParams = NULL;
                          m_memType = SYSTEM_MEMORY;
                          m_bExternalAlloc = false;
                          m_bDecOutSysmem = false;
                          MSDK_ZERO_MEMORY(m_mfxResponse);
                          MSDK_ZERO_MEMORY(m_mfxVppResponse);

                          m_pCurrentFreeSurface = NULL;
                          m_pCurrentFreeVppSurface = NULL;
                          m_pCurrentFreeOutputSurface = NULL;
                          m_pCurrentOutputSurface = NULL;

                          m_pDeliverOutputSemaphore = NULL;
                          m_pDeliveredEvent = NULL;
                          m_error = MFX_ERR_NONE;
                          m_bStopDeliverLoop = false;

                          m_eWorkMode = MODE_PERFORMANCE;
                          m_bIsMVC = false;
                          m_bIsExtBuffers = false;
                          m_bIsVideoWall = false;
                          m_bIsCompleteFrame = false;
                          m_bPrintLatency = false;
                          m_fourcc = 0;

                          m_nTimeout = 0;
                          m_nMaxFps = 0;

                          m_diMode = 0;
                          m_bRenderWin = false;
                          m_vppOutWidth  = 0;
                          m_vppOutHeight = 0;

                          m_nRenderWinX = 0;
                          m_nRenderWinY = 0;
                          m_nRenderWinH = 0;
                          m_nRenderWinW = 0;

                          m_bResetFileWriter = false;
                          m_bResetFileReader = false;

                          m_startTick = 0;
                          m_delayTicks = 0;

                          MSDK_ZERO_MEMORY(m_VppDoNotUse);
                          m_VppDoNotUse.Header.BufferId = MFX_EXTBUFF_VPP_DONOTUSE;
                          m_VppDoNotUse.Header.BufferSz = sizeof(m_VppDoNotUse);

                          MSDK_ZERO_MEMORY(m_VppDeinterlacing)
                          m_VppDeinterlacing.Header.BufferId = MFX_EXTBUFF_VPP_DEINTERLACING;
                          m_VppDeinterlacing.Header.BufferSz = sizeof(m_VppDeinterlacing);

                          MSDK_ZERO_MEMORY(m_VppVideoSignalInfo);
                          m_VppVideoSignalInfo.Header.BufferId = MFX_EXTBUFF_VPP_VIDEO_SIGNAL_INFO;
                          m_VppVideoSignalInfo.Header.BufferSz = sizeof(m_VppVideoSignalInfo);

                          m_hwdev = NULL;

                          m_bOutI420 = false;

                      #ifdef LIBVA_SUPPORT
                          m_export_mode = vaapiAllocatorParams::DONOT_EXPORT;
                          m_libvaBackend = 0;
                          m_bPerfMode = false;
                      #endif

                      #if D3D_SURFACES_SUPPORT
                          m_pS3DControl = NULL;
                      #endif

                          m_monitorType = 0;
                          m_vLatency.reserve(1000); // reserve some space to reduce dynamic reallocation impact on pipeline execution
                      }

                      CDecodingPipeline::~CDecodingPipeline()
                      {
                          Close();
                      }
                </ui-codemirror>
                </div>
            </div>
        </div>
    </div>

    <div class="row">
        <div class="col-lg-12">
            <div ibox title="Decoding Pipeline Initialization">
                <div content-block name="xdk-issues" message="Check after completing this section">
                  <ui-codemirror ui-codemirror-opts="editorOptions" id="topic-configure">
                    mfxStatus CDecodingPipeline::Init(sInputParams *pParams)
                    {
                      MSDK_CHECK_POINTER(pParams, MFX_ERR_NULL_PTR);

                      mfxStatus sts = MFX_ERR_NONE;

                      // prepare input stream file reader
                      // for VP8 complete and single frame reader is a requirement
                      // create reader that supports completeframe mode for latency oriented scenarios

                      if (pParams->bLowLat || pParams->bCalLat)
                      {
                          switch (pParams->videoType)
                          {
                          case MFX_CODEC_AVC:
                              m_FileReader.reset(new CH264FrameReader());
                              m_bIsCompleteFrame = true;
                              m_bPrintLatency = pParams->bCalLat;
                              break;
                          case MFX_CODEC_JPEG:
                              m_FileReader.reset(new CJPEGFrameReader());
                              m_bIsCompleteFrame = true;
                              m_bPrintLatency = pParams->bCalLat;
                              break;
                          case MFX_CODEC_VP8:
                          case MFX_CODEC_VP9:
                              m_FileReader.reset(new CIVFFrameReader());
                              m_bIsCompleteFrame = true;
                              m_bPrintLatency = pParams->bCalLat;
                              break;
                          default:
                              return MFX_ERR_UNSUPPORTED; // latency mode is supported only for H.264 and JPEG codecs
                          }
                      }
                      else
                      {
                          switch (pParams->videoType)
                          {
                          case MFX_CODEC_VP8:
                          case MFX_CODEC_VP9:
                              m_FileReader.reset(new CIVFFrameReader());
                              break;
                          default:
                              m_FileReader.reset(new CSmplBitstreamReader());
                              break;
                          }
                      }

                      if (pParams->fourcc)
                          m_fourcc = pParams->fourcc;

                    #ifdef LIBVA_SUPPORT
                      if(pParams->bPerfMode)
                          m_bPerfMode = true;
                    #endif

                      if (pParams->Width)
                          m_vppOutWidth = pParams->Width;
                      if (pParams->Height)
                          m_vppOutHeight = pParams->Height;


                      m_memType = pParams->memType;

                      m_nMaxFps = pParams->nMaxFPS;
                      m_nFrames = pParams->nFrames ? pParams->nFrames : MFX_INFINITE;

                      m_bOutI420 = pParams->outI420;

                      m_nTimeout = pParams->nTimeout;

                      if (MFX_CODEC_CAPTURE != pParams->videoType)
                      {
                          sts = m_FileReader->Init(pParams->strSrcFile);
                          MSDK_CHECK_STATUS(sts, "m_FileReader->Init failed");
                      }

                      mfxInitParam initPar;
                      mfxExtThreadsParam threadsPar;
                      mfxExtBuffer* extBufs[1];
                      mfxVersion version;     // real API version with which library is initialized

                      MSDK_ZERO_MEMORY(initPar);
                      MSDK_ZERO_MEMORY(threadsPar);

                      // we set version to 1.0 and later we will query actual version of the library which will got leaded
                      initPar.Version.Major = 1;
                      initPar.Version.Minor = 0;

                      initPar.GPUCopy = pParams->gpuCopy;

                      init_ext_buffer(threadsPar);

                      bool needInitExtPar = false;

                      if (pParams->eDeinterlace)
                      {
                          m_diMode = pParams->eDeinterlace;
                      }

                      if (pParams->bUseFullColorRange)
                      {
                          m_bVppFullColorRange = pParams->bUseFullColorRange;
                      }

                      if (pParams->nThreadsNum) {
                          threadsPar.NumThread = pParams->nThreadsNum;
                          needInitExtPar = true;
                      }
                      if (pParams->SchedulingType) {
                          threadsPar.SchedulingType = pParams->SchedulingType;
                          needInitExtPar = true;
                      }
                      if (pParams->Priority) {
                          threadsPar.Priority = pParams->Priority;
                          needInitExtPar = true;
                      }
                      if (needInitExtPar) {
                          extBufs[0] = (mfxExtBuffer*)&threadsPar;
                          initPar.ExtParam = extBufs;
                          initPar.NumExtParam = 1;
                      }

                      // Init session
                      if (pParams->bUseHWLib) {
                          // try searching on all display adapters
                          initPar.Implementation = MFX_IMPL_HARDWARE_ANY;

                          // if d3d11 surfaces are used ask the library to run acceleration through D3D11
                          // feature may be unsupported due to OS or MSDK API version

                          if (D3D11_MEMORY == pParams->memType)
                              initPar.Implementation |= MFX_IMPL_VIA_D3D11;

                          sts = m_mfxSession.InitEx(initPar);

                          // MSDK API version may not support multiple adapters - then try initialize on the default
                          if (MFX_ERR_NONE != sts) {
                              initPar.Implementation = (initPar.Implementation & !MFX_IMPL_HARDWARE_ANY) | MFX_IMPL_HARDWARE;
                              sts = m_mfxSession.InitEx(initPar);
                          }
                      } else {
                          initPar.Implementation = MFX_IMPL_SOFTWARE;
                          sts = m_mfxSession.InitEx(initPar);
                      }

                      MSDK_CHECK_STATUS(sts, "m_mfxSession.Init failed");

                      sts = m_mfxSession.QueryVersion(&version); // get real API version of the loaded library
                      MSDK_CHECK_STATUS(sts, "m_mfxSession.QueryVersion failed");

                      sts = m_mfxSession.QueryIMPL(&m_impl); // get actual library implementation
                      MSDK_CHECK_STATUS(sts, "m_mfxSession.QueryIMPL failed");

                      if (pParams->bIsMVC && !CheckVersion(&version, MSDK_FEATURE_MVC)) {
                          msdk_printf(MSDK_STRING("error: MVC is not supported in the %d.%d API version\n"),
                              version.Major, version.Minor);
                          return MFX_ERR_UNSUPPORTED;

                      }
                      if ((pParams->videoType == MFX_CODEC_JPEG) && !CheckVersion(&version, MSDK_FEATURE_JPEG_DECODE)) {
                          msdk_printf(MSDK_STRING("error: Jpeg is not supported in the %d.%d API version\n"),
                              version.Major, version.Minor);
                          return MFX_ERR_UNSUPPORTED;
                      }
                      if (pParams->bLowLat && !CheckVersion(&version, MSDK_FEATURE_LOW_LATENCY)) {
                          msdk_printf(MSDK_STRING("error: Low Latency mode is not supported in the %d.%d API version\n"),
                              version.Major, version.Minor);
                          return MFX_ERR_UNSUPPORTED;
                      }

                      if (pParams->eDeinterlace &&
                          (pParams->eDeinterlace != MFX_DEINTERLACING_ADVANCED) &&
                          (pParams->eDeinterlace != MFX_DEINTERLACING_BOB) )
                      {
                          msdk_printf(MSDK_STRING("error: Unsupported deinterlace value: %d\n"), pParams->eDeinterlace);
                          return MFX_ERR_UNSUPPORTED;
                      }

                      if (pParams->bRenderWin) {
                          m_bRenderWin = pParams->bRenderWin;
                          // note: currently position is unsupported for Wayland
                    #if !defined(LIBVA_WAYLAND_SUPPORT)
                          m_nRenderWinX = pParams->nRenderWinX;
                          m_nRenderWinY = pParams->nRenderWinY;
                    #endif
                      }

                      m_delayTicks = pParams->nMaxFPS ? msdk_time_get_frequency() / pParams->nMaxFPS : 0;

                      // create decoder
                      m_pmfxDEC = new MFXVideoDECODE(m_mfxSession);
                      MSDK_CHECK_POINTER(m_pmfxDEC, MFX_ERR_MEMORY_ALLOC);

                      // set video type in parameters
                      m_mfxVideoParams.mfx.CodecId = pParams->videoType;

                      // prepare bit stream
                      if (MFX_CODEC_CAPTURE != pParams->videoType)
                      {
                          sts = InitMfxBitstream(&m_mfxBS, 8 * 1024 * 1024);
                          MSDK_CHECK_STATUS(sts, "InitMfxBitstream failed");
                      }

                      if (CheckVersion(&version, MSDK_FEATURE_PLUGIN_API)) {

                          /* Here we actually define the following codec initialization scheme:
                          *  1. If plugin path or guid is specified: we load user-defined plugin (example: VP8 sample decoder plugin)
                          *  2. If plugin path not specified:
                          *    2.a) we check if codec is distributed as a mediasdk plugin and load it if yes
                          *    2.b) if codec is not in the list of mediasdk plugins, we assume, that it is supported inside mediasdk library
                          */
                          // Load user plug-in, should go after CreateAllocator function (when all callbacks were initialized)

                          if (pParams->pluginParams.type == MFX_PLUGINLOAD_TYPE_FILE && msdk_strnlen(pParams->pluginParams.strPluginPath,sizeof(pParams->pluginParams.strPluginPath)))
                          {
                              m_pUserModule.reset(new MFXVideoUSER(m_mfxSession));
                              if (pParams->videoType == MFX_CODEC_HEVC || pParams->videoType == MFX_CODEC_VP8 ||
                                  pParams->videoType == MFX_CODEC_VP9 || pParams->videoType == MFX_CODEC_CAPTURE)
                              {
                                  m_pPlugin.reset(LoadPlugin(MFX_PLUGINTYPE_VIDEO_DECODE, m_mfxSession, pParams->pluginParams.pluginGuid, 1, pParams->pluginParams.strPluginPath, (mfxU32)msdk_strnlen(pParams->pluginParams.strPluginPath,sizeof(pParams->pluginParams.strPluginPath))));
                              }
                              if (m_pPlugin.get() == NULL) sts = MFX_ERR_UNSUPPORTED;
                          }
                          else
                          {
                              if (AreGuidsEqual(pParams->pluginParams.pluginGuid, MSDK_PLUGINGUID_NULL))
                              {
                                  mfxIMPL impl = pParams->bUseHWLib ? MFX_IMPL_HARDWARE : MFX_IMPL_SOFTWARE;
                                  pParams->pluginParams.pluginGuid = msdkGetPluginUID(impl, MSDK_VDECODE, pParams->videoType);
                              }
                              if (!AreGuidsEqual(pParams->pluginParams.pluginGuid, MSDK_PLUGINGUID_NULL))
                              {
                                  m_pPlugin.reset(LoadPlugin(MFX_PLUGINTYPE_VIDEO_DECODE, m_mfxSession, pParams->pluginParams.pluginGuid, 1));
                                  if (m_pPlugin.get() == NULL) sts = MFX_ERR_UNSUPPORTED;
                              }
                              if(sts==MFX_ERR_UNSUPPORTED)
                              {
                                  msdk_printf(MSDK_STRING("Default plugin cannot be loaded (possibly you have to define plugin explicitly)\n"));
                              }
                          }
                          MSDK_CHECK_STATUS(sts, "Plugin load failed");
                      }

                      // Populate parameters. Involves DecodeHeader call
                      sts = InitMfxParams(pParams);
                      MSDK_CHECK_STATUS(sts, "InitMfxParams failed");

                      if (m_bVppIsUsed)
                          m_bDecOutSysmem = pParams->bUseHWLib ? false : true;
                      else
                          m_bDecOutSysmem = pParams->memType == SYSTEM_MEMORY;

                      if (m_bVppIsUsed)
                      {
                          m_pmfxVPP = new MFXVideoVPP(m_mfxSession);
                          if (!m_pmfxVPP) return MFX_ERR_MEMORY_ALLOC;
                      }

                      m_eWorkMode = pParams->mode;
                      if (m_eWorkMode == MODE_FILE_DUMP) {
                          // prepare YUV file writer
                          sts = m_FileWriter.Init(pParams->strDstFile, pParams->numViews);
                          MSDK_CHECK_STATUS(sts, "m_FileWriter.Init failed");
                      } else if ((m_eWorkMode != MODE_PERFORMANCE) && (m_eWorkMode != MODE_RENDERING)) {
                          msdk_printf(MSDK_STRING("error: unsupported work mode\n"));
                          return MFX_ERR_UNSUPPORTED;
                      }

                      m_monitorType = pParams->monitorType;
                      // create device and allocator
                    #if defined(LIBVA_SUPPORT)
                      m_libvaBackend = pParams->libvaBackend;
                    #endif // defined(MFX_LIBVA_SUPPORT)

                      sts = CreateAllocator();
                      MSDK_CHECK_STATUS(sts, "CreateAllocator failed");

                      // in case of HW accelerated decode frames must be allocated prior to decoder initialization
                      sts = AllocFrames();
                      MSDK_CHECK_STATUS(sts, "AllocFrames failed");

                      sts = m_pmfxDEC->Init(&m_mfxVideoParams);
                      if (MFX_WRN_PARTIAL_ACCELERATION == sts)
                      {
                          msdk_printf(MSDK_STRING("WARNING: partial acceleration\n"));
                          MSDK_IGNORE_MFX_STS(sts, MFX_WRN_PARTIAL_ACCELERATION);
                      }
                      MSDK_CHECK_STATUS(sts, "m_pmfxDEC->Init failed");

                      if (m_bVppIsUsed)
                      {
                          if (m_diMode)
                              m_mfxVppVideoParams.vpp.Out.PicStruct = MFX_PICSTRUCT_PROGRESSIVE;

                          sts = m_pmfxVPP->Init(&m_mfxVppVideoParams);
                          if (MFX_WRN_PARTIAL_ACCELERATION == sts)
                          {
                              msdk_printf(MSDK_STRING("WARNING: partial acceleration\n"));
                              MSDK_IGNORE_MFX_STS(sts, MFX_WRN_PARTIAL_ACCELERATION);
                          }
                          MSDK_CHECK_STATUS(sts, "m_pmfxVPP->Init failed");
                      }

                      sts = m_pmfxDEC->GetVideoParam(&m_mfxVideoParams);
                      MSDK_CHECK_STATUS(sts, "m_pmfxDEC->GetVideoParam failed");

                      if (m_eWorkMode == MODE_RENDERING)
                      {
                          sts = CreateRenderingWindow(pParams, m_bIsMVC && (m_memType == D3D9_MEMORY));
                          MSDK_CHECK_STATUS(sts, "CreateRenderingWindow failed");
                      }

                      return sts;
                    }
                  </ui-codemirror>
                </div>
            </div>
        </div>
    </div>

    <div class="row">
        <div class="col-lg-12">
            <div ibox title="Video Pre/Post Processing Requirement Check">
                <div content-block name="xdk-issues" message="Check after completing this section">
                  <ui-codemirror ui-codemirror-opts="editorOptions" id="topic-configure">
                    bool CDecodingPipeline::IsVppRequired(sInputParams *pParams)
                    {
                        bool bVppIsUsed = false;
                        // JPEG and Capture decoders can provide output in nv12 and rgb4 formats
                        if ((pParams->videoType == MFX_CODEC_JPEG) ||
                            ((pParams->videoType == MFX_CODEC_CAPTURE)) )
                        {
                            bVppIsUsed = m_fourcc && (m_fourcc != MFX_FOURCC_NV12) && (m_fourcc != MFX_FOURCC_RGB4);
                        }
                        else
                        {
                            bVppIsUsed = m_fourcc && (m_fourcc != m_mfxVideoParams.mfx.FrameInfo.FourCC);
                        }

                        if ( (m_mfxVideoParams.mfx.FrameInfo.CropW != pParams->Width) ||
                            (m_mfxVideoParams.mfx.FrameInfo.CropH != pParams->Height) )
                        {
                            bVppIsUsed |= pParams->Width && pParams->Height;
                        }

                        if (pParams->eDeinterlace)
                        {
                            bVppIsUsed = true;
                        }
                        return bVppIsUsed;
                    }
                  </ui-codemirror>
                </div>
            </div>
        </div>
    </div>

    <div class="row">
        <div class="col-lg-12">
            <div ibox title="Closing the Decode Pipeline">
                <div content-block name="xdk-issues" message="Check after completing this section">
                  <ui-codemirror ui-codemirror-opts="editorOptions" id="topic-configure">
                    void CDecodingPipeline::Close()
                    {
                    #if D3D_SURFACES_SUPPORT
                        if (NULL != m_pS3DControl)
                        {
                            m_pS3DControl->SwitchTo2D(NULL);
                            MSDK_SAFE_DELETE(m_pS3DControl);
                        }
                    #endif
                        WipeMfxBitstream(&m_mfxBS);
                        MSDK_SAFE_DELETE(m_pmfxDEC);
                        MSDK_SAFE_DELETE(m_pmfxVPP);

                        DeleteFrames();

                        if (m_bIsExtBuffers)
                        {
                            DeallocateExtMVCBuffers();
                            DeleteExtBuffers();
                        }

                        m_pPlugin.reset();
                        m_mfxSession.Close();
                        m_FileWriter.Close();
                        if (m_FileReader.get())
                            m_FileReader->Close();

                        MSDK_SAFE_DELETE_ARRAY(m_VppDoNotUse.AlgList);

                        // allocator if used as external for MediaSDK must be deleted after decoder
                        DeleteAllocator();

                        return;
                    }

                    #if D3D_SURFACES_SUPPORT
                    bool operator &lt (const IGFX_DISPLAY_MODE &l, const IGFX_DISPLAY_MODE& r)
                    {
                        if (r.ulResWidth &gt= 0xFFFF || r.ulResHeight &gt= 0xFFFF || r.ulRefreshRate &gt= 0xFFFF)
                            return false;

                             if (l.ulResWidth &lt r.ulResWidth) return true;
                        else if (l.ulResHeight &lt r.ulResHeight) return true;
                        else if (l.ulRefreshRate &lt r.ulRefreshRate) return true;

                        return false;
                    }
                    #endif


                  </ui-codemirror>
                </div>
            </div>
        </div>
    </div>

    <div class="row">
        <div class="col-lg-12">
            <div ibox title="Rendering Window Creation">
                <div content-block name="xdk-issues" message="Check after completing this section">
                  <ui-codemirror ui-codemirror-opts="editorOptions" id="topic-configure">
                    mfxStatus CDecodingPipeline::CreateRenderingWindow(sInputParams *pParams, bool try_s3d)
                    {
                      mfxStatus sts = MFX_ERR_NONE;

                    #if D3D_SURFACES_SUPPORT
                      if (try_s3d) {

                          m_pS3DControl = CreateIGFXS3DControl();
                          MSDK_CHECK_POINTER(m_pS3DControl, MFX_ERR_DEVICE_FAILED);

                          // check if s3d supported and get a list of supported display modes
                          IGFX_S3DCAPS caps;
                          MSDK_ZERO_MEMORY(caps);
                          HRESULT hr = m_pS3DControl->GetS3DCaps(&caps);
                          if (FAILED(hr) || 0 &gt= caps.ulNumEntries) {
                              MSDK_SAFE_DELETE(m_pS3DControl);
                              return MFX_ERR_DEVICE_FAILED;
                          }

                          // switch to 3D mode
                          ULONG max = 0;
                          MSDK_CHECK_POINTER(caps.S3DSupportedModes, MFX_ERR_NOT_INITIALIZED);
                          for (ULONG i = 0; i &lt caps.ulNumEntries; i++) {
                              if (caps.S3DSupportedModes[max] &lt caps.S3DSupportedModes[i])
                                  max = i;
                          }

                          if (0 == pParams->nWallCell) {
                              hr = m_pS3DControl->SwitchTo3D(&caps.S3DSupportedModes[max]);
                              if (FAILED(hr)) {
                                  MSDK_SAFE_DELETE(m_pS3DControl);
                                  return MFX_ERR_DEVICE_FAILED;
                              }
                          }
                      }
                      sWindowParams windowParams;

                      windowParams.lpWindowName = pParams->bWallNoTitle ? NULL : MSDK_STRING("sample_decode");
                      windowParams.nx           = pParams->nWallW;
                      windowParams.ny           = pParams->nWallH;
                      if (m_bVppIsUsed)
                      {
                          windowParams.nWidth       = m_mfxVppVideoParams.vpp.Out.Width;
                          windowParams.nHeight      = m_mfxVppVideoParams.vpp.Out.Height;
                      }
                      else
                      {
                          windowParams.nWidth       = m_mfxVideoParams.mfx.FrameInfo.Width;
                          windowParams.nHeight      = m_mfxVideoParams.mfx.FrameInfo.Height;
                      }

                      windowParams.ncell        = pParams->nWallCell;
                      windowParams.nAdapter     = pParams->nWallMonitor;

                      windowParams.lpClassName  = MSDK_STRING("Render Window Class");
                      windowParams.dwStyle      = WS_OVERLAPPEDWINDOW;
                      windowParams.hWndParent   = NULL;
                      windowParams.hMenu        = NULL;
                      windowParams.hInstance    = GetModuleHandle(NULL);
                      windowParams.lpParam      = NULL;
                      windowParams.bFullScreen  = FALSE;

                      sts = m_d3dRender.Init(windowParams);
                      MSDK_CHECK_STATUS(sts, "m_d3dRender.Init failed");

                      //setting videowall flag
                      m_bIsVideoWall = 0 != windowParams.nx;

                    #endif
                      return sts;
                    }
                  </ui-codemirror>
                </div>
            </div>
        </div>
    </div>

    <div class="row">
        <div class="col-lg-12">
            <div ibox title="Initialization of Multi format codecs (mfx) Parameters">
                <div content-block name="xdk-issues" message="Check after completing this section">
                  <ui-codemirror ui-codemirror-opts="editorOptions" id="topic-configure">
                    mfxStatus CDecodingPipeline::InitMfxParams(sInputParams *pParams)
                    {
                        MSDK_CHECK_POINTER(m_pmfxDEC, MFX_ERR_NULL_PTR);
                        mfxStatus sts = MFX_ERR_NONE;
                        mfxU32 &numViews = pParams->numViews;

                        // try to find a sequence header in the stream
                        // if header is not found this function exits with error (e.g. if device was lost and there's no header in the remaining stream)
                        if (MFX_CODEC_CAPTURE == pParams->videoType)
                        {
                            m_mfxVideoParams.mfx.CodecId = MFX_CODEC_CAPTURE;
                            m_mfxVideoParams.mfx.FrameInfo.PicStruct = MFX_PICSTRUCT_PROGRESSIVE;
                            m_mfxVideoParams.mfx.FrameInfo.Width = MSDK_ALIGN32(pParams->scrWidth);
                            m_mfxVideoParams.mfx.FrameInfo.Height = MSDK_ALIGN32(pParams->scrHeight);
                            m_mfxVideoParams.mfx.FrameInfo.CropW = pParams->scrWidth;
                            m_mfxVideoParams.mfx.FrameInfo.CropH = pParams->scrHeight;
                            m_mfxVideoParams.mfx.FrameInfo.FourCC = (m_fourcc == MFX_FOURCC_RGB4) ? MFX_FOURCC_RGB4 : MFX_FOURCC_NV12;

                            if (!m_mfxVideoParams.mfx.FrameInfo.ChromaFormat)
                            {
                                if (MFX_FOURCC_NV12 == m_mfxVideoParams.mfx.FrameInfo.FourCC)
                                    m_mfxVideoParams.mfx.FrameInfo.ChromaFormat = MFX_CHROMAFORMAT_YUV420;
                                else if (MFX_FOURCC_RGB4 == m_mfxVideoParams.mfx.FrameInfo.FourCC)
                                    m_mfxVideoParams.mfx.FrameInfo.ChromaFormat = MFX_CHROMAFORMAT_YUV444;
                            }
                            m_bVppIsUsed = IsVppRequired(pParams);
                        }

                        for (; MFX_CODEC_CAPTURE != pParams->videoType;)
                        {
                            // trying to find PicStruct information in AVI headers
                            if ( m_mfxVideoParams.mfx.CodecId == MFX_CODEC_JPEG )
                                MJPEG_AVI_ParsePicStruct(&m_mfxBS);

                            // parse bit stream and fill mfx params
                            sts = m_pmfxDEC->DecodeHeader(&m_mfxBS, &m_mfxVideoParams);
                            if (!sts)
                            {
                                m_bVppIsUsed = IsVppRequired(pParams);
                            }

                            if (!sts &&
                                !(m_impl & MFX_IMPL_SOFTWARE) &&                        // hw lib
                                (m_mfxVideoParams.mfx.FrameInfo.BitDepthLuma == 10) &&  // hevc 10 bit
                                (m_mfxVideoParams.mfx.CodecId == MFX_CODEC_HEVC) &&
                                AreGuidsEqual(pParams->pluginParams.pluginGuid, MFX_PLUGINID_HEVCD_SW) && // sw hevc decoder
                                m_bVppIsUsed )
                            {
                                sts = MFX_ERR_UNSUPPORTED;
                                msdk_printf(MSDK_STRING("Error: Combination of (SW HEVC plugin in 10bit mode + HW lib VPP) isn't supported. Use -sw option.\n"));
                            }
                            if (m_pPlugin.get() && pParams->videoType == CODEC_VP8 && !sts) {
                                // force set format to nv12 as the vp8 plugin uses yv12
                                m_mfxVideoParams.mfx.FrameInfo.FourCC = MFX_FOURCC_NV12;
                            }
                            if (MFX_ERR_MORE_DATA == sts)
                            {
                                if (m_mfxBS.MaxLength == m_mfxBS.DataLength)
                                {
                                    sts = ExtendMfxBitstream(&m_mfxBS, m_mfxBS.MaxLength * 2);
                                    MSDK_CHECK_STATUS(sts, "ExtendMfxBitstream failed");
                                }
                                // read a portion of data
                                sts = m_FileReader->ReadNextFrame(&m_mfxBS);
                                if (MFX_ERR_MORE_DATA == sts &&
                                    !(m_mfxBS.DataFlag & MFX_BITSTREAM_EOS))
                                {
                                    m_mfxBS.DataFlag |= MFX_BITSTREAM_EOS;
                                    sts = MFX_ERR_NONE;
                                }
                                MSDK_CHECK_STATUS(sts, "m_FileReader->ReadNextFrame failed");

                                continue;
                            }
                            else
                            {
                                // Enter MVC mode
                                if (m_bIsMVC)
                                {
                                    // Check for attached external parameters - if we have them already,
                                    // we don't need to attach them again
                                    if (NULL != m_mfxVideoParams.ExtParam)
                                        break;

                                    // allocate and attach external parameters for MVC decoder
                                    sts = AllocateExtBuffer&ltmfxExtMVCSeqDesc&gt();
                                    MSDK_CHECK_STATUS(sts, "AllocateExtBuffer&ltmfxExtMVCSeqDesc&gt failed");

                                    AttachExtParam();
                                    sts = m_pmfxDEC->DecodeHeader(&m_mfxBS, &m_mfxVideoParams);

                                    if (MFX_ERR_NOT_ENOUGH_BUFFER == sts)
                                    {
                                        sts = AllocateExtMVCBuffers();
                                        SetExtBuffersFlag();

                                        MSDK_CHECK_STATUS(sts, "AllocateExtMVCBuffers failed");
                                        MSDK_CHECK_POINTER(m_mfxVideoParams.ExtParam, MFX_ERR_MEMORY_ALLOC);
                                        continue;
                                    }
                                }

                                // if input is interlaced JPEG stream
                                if ( m_mfxBS.PicStruct == MFX_PICSTRUCT_FIELD_TFF || m_mfxBS.PicStruct == MFX_PICSTRUCT_FIELD_BFF)
                                {
                                    m_mfxVideoParams.mfx.FrameInfo.CropH *= 2;
                                    m_mfxVideoParams.mfx.FrameInfo.Height = MSDK_ALIGN16(m_mfxVideoParams.mfx.FrameInfo.CropH);
                                    m_mfxVideoParams.mfx.FrameInfo.PicStruct = m_mfxBS.PicStruct;
                                }

                                switch(pParams->nRotation)
                                {
                                case 0:
                                    m_mfxVideoParams.mfx.Rotation = MFX_ROTATION_0;
                                    break;
                                case 90:
                                    m_mfxVideoParams.mfx.Rotation = MFX_ROTATION_90;
                                    break;
                                case 180:
                                    m_mfxVideoParams.mfx.Rotation = MFX_ROTATION_180;
                                    break;
                                case 270:
                                    m_mfxVideoParams.mfx.Rotation = MFX_ROTATION_270;
                                    break;
                                default:
                                    return MFX_ERR_UNSUPPORTED;
                                }

                                break;
                            }
                        }

                        // check DecodeHeader status
                        if (MFX_WRN_PARTIAL_ACCELERATION == sts)
                        {
                            msdk_printf(MSDK_STRING("WARNING: partial acceleration\n"));
                            MSDK_IGNORE_MFX_STS(sts, MFX_WRN_PARTIAL_ACCELERATION);
                        }
                        MSDK_CHECK_STATUS(sts, "m_pmfxDEC->DecodeHeader failed");

                        if (!m_mfxVideoParams.mfx.FrameInfo.FrameRateExtN || !m_mfxVideoParams.mfx.FrameInfo.FrameRateExtD) {
                            msdk_printf(MSDK_STRING("pretending that stream is 30fps one\n"));
                            m_mfxVideoParams.mfx.FrameInfo.FrameRateExtN = 30;
                            m_mfxVideoParams.mfx.FrameInfo.FrameRateExtD = 1;
                        }
                        if (!m_mfxVideoParams.mfx.FrameInfo.AspectRatioW || !m_mfxVideoParams.mfx.FrameInfo.AspectRatioH) {
                            msdk_printf(MSDK_STRING("pretending that aspect ratio is 1:1\n"));
                            m_mfxVideoParams.mfx.FrameInfo.AspectRatioW = 1;
                            m_mfxVideoParams.mfx.FrameInfo.AspectRatioH = 1;
                        }

                        // Videoparams for RGB4 JPEG decoder output
                        if ((pParams->fourcc == MFX_FOURCC_RGB4) && (pParams->videoType == MFX_CODEC_JPEG))
                        {
                            m_mfxVideoParams.mfx.FrameInfo.FourCC = MFX_FOURCC_RGB4;
                            m_mfxVideoParams.mfx.FrameInfo.ChromaFormat = MFX_CHROMAFORMAT_YUV444;
                            if (pParams->chromaType == MFX_JPEG_COLORFORMAT_RGB)
                            {
                                m_mfxVideoParams.mfx.JPEGColorFormat = pParams->chromaType;
                            }
                        }

                        // If MVC mode we need to detect number of views in stream
                        if (m_bIsMVC)
                        {
                            mfxExtMVCSeqDesc* pSequenceBuffer;
                            pSequenceBuffer = (mfxExtMVCSeqDesc*) GetExtBuffer(m_mfxVideoParams.ExtParam, m_mfxVideoParams.NumExtParam, MFX_EXTBUFF_MVC_SEQ_DESC);
                            MSDK_CHECK_POINTER(pSequenceBuffer, MFX_ERR_INVALID_VIDEO_PARAM);

                            mfxU32 i = 0;
                            numViews = 0;
                            for (i = 0; i &lt pSequenceBuffer->NumView; ++i)
                            {
                                /* Some MVC streams can contain different information about
                                   number of views and view IDs, e.x. numVews = 2
                                   and ViewId[0, 1] = 0, 2 instead of ViewId[0, 1] = 0, 1.
                                   numViews should be equal (max(ViewId[i]) + 1)
                                   to prevent crashes during output files writing */
                                if (pSequenceBuffer->View[i].ViewId &gt= numViews)
                                    numViews = pSequenceBuffer->View[i].ViewId + 1;
                            }
                        }
                        else
                        {
                            numViews = 1;
                        }

                        // specify memory type
                        if (!m_bVppIsUsed)
                            m_mfxVideoParams.IOPattern = (mfxU16)(m_memType != SYSTEM_MEMORY ? MFX_IOPATTERN_OUT_VIDEO_MEMORY : MFX_IOPATTERN_OUT_SYSTEM_MEMORY);
                        else
                            m_mfxVideoParams.IOPattern = (mfxU16)(pParams->bUseHWLib ? MFX_IOPATTERN_OUT_VIDEO_MEMORY : MFX_IOPATTERN_OUT_SYSTEM_MEMORY);

                        m_mfxVideoParams.AsyncDepth = pParams->nAsyncDepth;

                        return MFX_ERR_NONE;
                    }

                  </ui-codemirror>
                </div>
            </div>
        </div>
    </div>

    <div class="row">
        <div class="col-lg-12">
            <div ibox title="Create and reset Hardware device ">
                <div content-block name="xdk-issues" message="Check after completing this section">
                  <ui-codemirror ui-codemirror-opts="editorOptions" id="topic-configure">
                    mfxStatus CDecodingPipeline::CreateHWDevice()
                    {
                    #if D3D_SURFACES_SUPPORT
                        mfxStatus sts = MFX_ERR_NONE;

                        HWND window = NULL;
                        bool render = (m_eWorkMode == MODE_RENDERING);

                        if (render) {
                            window = (D3D11_MEMORY == m_memType) ? NULL : m_d3dRender.GetWindowHandle();
                        }

                    #if MFX_D3D11_SUPPORT
                        if (D3D11_MEMORY == m_memType)
                            m_hwdev = new CD3D11Device();
                        else
                    #endif // #if MFX_D3D11_SUPPORT
                            m_hwdev = new CD3D9Device();

                        if (NULL == m_hwdev)
                            return MFX_ERR_MEMORY_ALLOC;

                        if (render && m_bIsMVC && m_memType == D3D9_MEMORY) {
                            sts = m_hwdev->SetHandle((mfxHandleType)MFX_HANDLE_GFXS3DCONTROL, m_pS3DControl);
                            MSDK_CHECK_STATUS(sts, "m_hwdev->SetHandle failed");
                        }
                        sts = m_hwdev->Init(
                            window,
                            render ? (m_bIsMVC ? 2 : 1) : 0,
                            MSDKAdapter::GetNumber(m_mfxSession));
                        MSDK_CHECK_STATUS(sts, "m_hwdev->Init failed");

                        if (render)
                            m_d3dRender.SetHWDevice(m_hwdev);
                    #elif LIBVA_SUPPORT
                        mfxStatus sts = MFX_ERR_NONE;
                        m_hwdev = CreateVAAPIDevice(m_libvaBackend);

                        if (NULL == m_hwdev) {
                            return MFX_ERR_MEMORY_ALLOC;
                        }

                        sts = m_hwdev->Init(&m_monitorType, (m_eWorkMode == MODE_RENDERING) ? 1 : 0, MSDKAdapter::GetNumber(m_mfxSession));
                        MSDK_CHECK_STATUS(sts, "m_hwdev->Init failed");

                    #if defined(LIBVA_WAYLAND_SUPPORT)
                        if (m_eWorkMode == MODE_RENDERING && m_libvaBackend == MFX_LIBVA_WAYLAND) {
                            mfxHDL hdl = NULL;
                            mfxHandleType hdlw_t = (mfxHandleType)HANDLE_WAYLAND_DRIVER;
                            Wayland *wld;
                            sts = m_hwdev->GetHandle(hdlw_t, &hdl);
                            MSDK_CHECK_STATUS(sts, "m_hwdev->GetHandle failed");
                            wld = (Wayland*)hdl;
                            wld->SetRenderWinPos(m_nRenderWinX, m_nRenderWinY);
                            wld->SetPerfMode(m_bPerfMode);
                        }
                    #endif //LIBVA_WAYLAND_SUPPORT

                    #endif
                        return MFX_ERR_NONE;
                    }

                    mfxStatus CDecodingPipeline::ResetDevice()
                    {
                        return m_hwdev->Reset();
                    }
                  </ui-codemirror>
                </div>
            </div>
        </div>
    </div>

    <div class="row">
        <div class="col-lg-12">
            <div ibox title="Allocate Frames">
                <div content-block name="xdk-issues" message="Check after completing this section">
                  <ui-codemirror ui-codemirror-opts="editorOptions" id="topic-configure">
                    mfxStatus CDecodingPipeline::AllocFrames()
                    {
                        MSDK_CHECK_POINTER(m_pmfxDEC, MFX_ERR_NULL_PTR);

                        mfxStatus sts = MFX_ERR_NONE;

                        mfxFrameAllocRequest Request;
                        mfxFrameAllocRequest VppRequest[2];

                        mfxU16 nSurfNum = 0; // number of surfaces for decoder
                        mfxU16 nVppSurfNum = 0; // number of surfaces for vpp

                        MSDK_ZERO_MEMORY(Request);
                        MSDK_ZERO_MEMORY(VppRequest[0]);
                        MSDK_ZERO_MEMORY(VppRequest[1]);

                        sts = m_pmfxDEC->Query(&m_mfxVideoParams, &m_mfxVideoParams);
                        MSDK_IGNORE_MFX_STS(sts, MFX_WRN_INCOMPATIBLE_VIDEO_PARAM);
                        MSDK_CHECK_STATUS(sts, "m_pmfxDEC->Query failed");

                        // calculate number of surfaces required for decoder
                        sts = m_pmfxDEC->QueryIOSurf(&m_mfxVideoParams, &Request);
                        if (MFX_WRN_PARTIAL_ACCELERATION == sts)
                        {
                            msdk_printf(MSDK_STRING("WARNING: partial acceleration\n"));
                            MSDK_IGNORE_MFX_STS(sts, MFX_WRN_PARTIAL_ACCELERATION);
                            m_bDecOutSysmem = true;
                        }
                        MSDK_CHECK_STATUS(sts, "m_pmfxDEC->QueryIOSurf failed");

                        if (m_nMaxFps)
                        {
                            // Add surfaces for rendering smoothness
                            Request.NumFrameSuggested += m_nMaxFps / 3;
                        }

                        if (m_bVppIsUsed)
                        {
                            // respecify memory type between Decoder and VPP
                            m_mfxVideoParams.IOPattern = (mfxU16)( m_bDecOutSysmem ?
                                    MFX_IOPATTERN_OUT_SYSTEM_MEMORY:
                                    MFX_IOPATTERN_OUT_VIDEO_MEMORY);

                            // recalculate number of surfaces required for decoder
                            sts = m_pmfxDEC->QueryIOSurf(&m_mfxVideoParams, &Request);
                            MSDK_IGNORE_MFX_STS(sts, MFX_WRN_PARTIAL_ACCELERATION);
                            MSDK_CHECK_STATUS(sts, "m_pmfxDEC->QueryIOSurf failed");


                            sts = InitVppParams();
                            MSDK_CHECK_STATUS(sts, "InitVppParams failed");

                            sts = m_pmfxVPP->Query(&m_mfxVppVideoParams, &m_mfxVppVideoParams);
                            MSDK_IGNORE_MFX_STS(sts, MFX_WRN_INCOMPATIBLE_VIDEO_PARAM);
                            MSDK_CHECK_STATUS(sts, "m_pmfxVPP->Query failed");

                            // VppRequest[0] for input frames request, VppRequest[1] for output frames request
                            sts = m_pmfxVPP->QueryIOSurf(&m_mfxVppVideoParams, VppRequest);
                            if (MFX_WRN_PARTIAL_ACCELERATION == sts) {
                                msdk_printf(MSDK_STRING("WARNING: partial acceleration\n"));
                                MSDK_IGNORE_MFX_STS(sts, MFX_WRN_PARTIAL_ACCELERATION);
                            }
                            MSDK_CHECK_STATUS(sts, "m_pmfxVPP->QueryIOSurf failed");

                            if ((VppRequest[0].NumFrameSuggested &lt m_mfxVppVideoParams.AsyncDepth) ||
                                (VppRequest[1].NumFrameSuggested &lt m_mfxVppVideoParams.AsyncDepth))
                                return MFX_ERR_MEMORY_ALLOC;


                            // If surfaces are shared by 2 components, c1 and c2. NumSurf = c1_out + c2_in - AsyncDepth + 1
                            // The number of surfaces shared by vpp input and decode output
                            nSurfNum = Request.NumFrameSuggested + VppRequest[0].NumFrameSuggested - m_mfxVideoParams.AsyncDepth + 1;

                            // The number of surfaces for vpp output
                            nVppSurfNum = VppRequest[1].NumFrameSuggested;

                            // prepare allocation request
                            Request.NumFrameSuggested = Request.NumFrameMin = nSurfNum;

                            // surfaces are shared between vpp input and decode output
                            Request.Type = MFX_MEMTYPE_EXTERNAL_FRAME | MFX_MEMTYPE_FROM_DECODE | MFX_MEMTYPE_FROM_VPPIN;
                        }

                        if ((Request.NumFrameSuggested &lt m_mfxVideoParams.AsyncDepth) &&
                            (m_impl & MFX_IMPL_HARDWARE_ANY))
                            return MFX_ERR_MEMORY_ALLOC;

                        Request.Type |= (m_bDecOutSysmem) ?
                            MFX_MEMTYPE_SYSTEM_MEMORY
                            : MFX_MEMTYPE_VIDEO_MEMORY_DECODER_TARGET;

                    #ifdef LIBVA_SUPPORT
                        if (!m_bVppIsUsed &&
                            (m_export_mode != vaapiAllocatorParams::DONOT_EXPORT))
                        {
                            Request.Type |= MFX_MEMTYPE_EXPORT_FRAME;
                        }
                    #endif

                        // alloc frames for decoder
                        sts = m_pGeneralAllocator->Alloc(m_pGeneralAllocator->pthis, &Request, &m_mfxResponse);
                        MSDK_CHECK_STATUS(sts, "m_pGeneralAllocator->Alloc failed");

                        if (m_bVppIsUsed)
                        {
                            // alloc frames for VPP
                    #ifdef LIBVA_SUPPORT
                            if (m_export_mode != vaapiAllocatorParams::DONOT_EXPORT)
                            {
                                VppRequest[1].Type |= MFX_MEMTYPE_EXPORT_FRAME;
                            }
                    #endif
                            VppRequest[1].NumFrameSuggested = VppRequest[1].NumFrameMin = nVppSurfNum;
                            MSDK_MEMCPY_VAR(VppRequest[1].Info, &(m_mfxVppVideoParams.vpp.Out), sizeof(mfxFrameInfo));

                            sts = m_pGeneralAllocator->Alloc(m_pGeneralAllocator->pthis, &VppRequest[1], &m_mfxVppResponse);
                            MSDK_CHECK_STATUS(sts, "m_pGeneralAllocator->Alloc failed");

                            // prepare mfxFrameSurface1 array for decoder
                            nVppSurfNum = m_mfxVppResponse.NumFrameActual;

                            // AllocVppBuffers should call before AllocBuffers to set the value of m_OutputSurfacesNumber
                            sts = AllocVppBuffers(nVppSurfNum);
                            MSDK_CHECK_STATUS(sts, "AllocVppBuffers failed");
                        }

                        // prepare mfxFrameSurface1 array for decoder
                        nSurfNum = m_mfxResponse.NumFrameActual;

                        sts = AllocBuffers(nSurfNum);
                        MSDK_CHECK_STATUS(sts, "AllocBuffers failed");

                        for (int i = 0; i &lt nSurfNum; i++)
                        {
                            // initating each frame:
                            MSDK_MEMCPY_VAR(m_pSurfaces[i].frame.Info, &(Request.Info), sizeof(mfxFrameInfo));
                            if (m_bExternalAlloc) {
                                m_pSurfaces[i].frame.Data.MemId = m_mfxResponse.mids[i];
                                if (m_bVppFullColorRange)
                                {
                                    m_pSurfaces[i].frame.Data.ExtParam = &m_VppSurfaceExtParams[0];
                                    m_pSurfaces[i].frame.Data.NumExtParam = (mfxU16)m_VppSurfaceExtParams.size();
                                }
                            }
                            else {
                                sts = m_pGeneralAllocator->Lock(m_pGeneralAllocator->pthis, m_mfxResponse.mids[i], &(m_pSurfaces[i].frame.Data));
                                MSDK_CHECK_STATUS(sts, "m_pGeneralAllocator->Lock failed");
                            }
                        }

                        // prepare mfxFrameSurface1 array for VPP
                        for (int i = 0; i &lt nVppSurfNum; i++) {
                            MSDK_MEMCPY_VAR(m_pVppSurfaces[i].frame.Info, &(VppRequest[1].Info), sizeof(mfxFrameInfo));
                            if (m_bExternalAlloc) {
                                m_pVppSurfaces[i].frame.Data.MemId = m_mfxVppResponse.mids[i];
                                if (m_bVppFullColorRange)
                                {
                                    m_pVppSurfaces[i].frame.Data.ExtParam = &m_VppSurfaceExtParams[0];
                                    m_pVppSurfaces[i].frame.Data.NumExtParam = (mfxU16)m_VppSurfaceExtParams.size();
                                }
                            }
                            else {
                                sts = m_pGeneralAllocator->Lock(m_pGeneralAllocator->pthis, m_mfxVppResponse.mids[i], &(m_pVppSurfaces[i].frame.Data));
                                if (MFX_ERR_NONE != sts) {
                                    return sts;
                                }
                            }
                        }
                        return MFX_ERR_NONE;
                    }

                  </ui-codemirror>
                </div>
            </div>
        </div>
    </div>

    <div class="row">
        <div class="col-lg-12">
            <div ibox title="Create Allocator">
                <div content-block name="xdk-issues" message="Check after completing this section">
                  <ui-codemirror ui-codemirror-opts="editorOptions" id="topic-configure">
                    mfxStatus CDecodingPipeline::CreateAllocator()
                    {
                      mfxStatus sts = MFX_ERR_NONE;

                      m_pGeneralAllocator = new GeneralAllocator();
                      if (m_memType != SYSTEM_MEMORY || !m_bDecOutSysmem)
                      {
                    #if D3D_SURFACES_SUPPORT
                          sts = CreateHWDevice();
                          MSDK_CHECK_STATUS(sts, "CreateHWDevice failed");

                          // provide device manager to MediaSDK
                          mfxHDL hdl = NULL;
                          mfxHandleType hdl_t =
                    #if MFX_D3D11_SUPPORT
                              D3D11_MEMORY == m_memType ? MFX_HANDLE_D3D11_DEVICE :
                    #endif // #if MFX_D3D11_SUPPORT
                              MFX_HANDLE_D3D9_DEVICE_MANAGER;

                          sts = m_hwdev->GetHandle(hdl_t, &hdl);
                          MSDK_CHECK_STATUS(sts, "m_hwdev->GetHandle failed");
                          sts = m_mfxSession.SetHandle(hdl_t, hdl);
                          MSDK_CHECK_STATUS(sts, "m_mfxSession.SetHandle failed");

                          // create D3D allocator
                    #if MFX_D3D11_SUPPORT
                          if (D3D11_MEMORY == m_memType)
                          {
                              D3D11AllocatorParams *pd3dAllocParams = new D3D11AllocatorParams;
                              MSDK_CHECK_POINTER(pd3dAllocParams, MFX_ERR_MEMORY_ALLOC);
                              pd3dAllocParams->pDevice = reinterpret_cast&ltID3D11Device *&gt(hdl);

                              m_pmfxAllocatorParams = pd3dAllocParams;
                          }
                          else
                    #endif // #if MFX_D3D11_SUPPORT
                          {
                              D3DAllocatorParams *pd3dAllocParams = new D3DAllocatorParams;
                              MSDK_CHECK_POINTER(pd3dAllocParams, MFX_ERR_MEMORY_ALLOC);
                              pd3dAllocParams->pManager = reinterpret_cast&ltIDirect3DDeviceManager9 *&gt(hdl);

                              m_pmfxAllocatorParams = pd3dAllocParams;
                          }

                          /* In case of video memory we must provide MediaSDK with external allocator
                          thus we demonstrate "external allocator" usage model.
                          Call SetAllocator to pass allocator to mediasdk */
                          sts = m_mfxSession.SetFrameAllocator(m_pGeneralAllocator);
                          MSDK_CHECK_STATUS(sts, "m_mfxSession.SetFrameAllocator failed");

                          m_bExternalAlloc = true;
                    #elif LIBVA_SUPPORT
                          sts = CreateHWDevice();
                          MSDK_CHECK_STATUS(sts, "CreateHWDevice failed");
                          /* It's possible to skip failed result here and switch to SW implementation,
                             but we don't process this way */

                          // provide device manager to MediaSDK
                          VADisplay va_dpy = NULL;
                          sts = m_hwdev->GetHandle(MFX_HANDLE_VA_DISPLAY, (mfxHDL *)&va_dpy);
                          MSDK_CHECK_STATUS(sts, "m_hwdev->GetHandle failed");
                          sts = m_mfxSession.SetHandle(MFX_HANDLE_VA_DISPLAY, va_dpy);
                          MSDK_CHECK_STATUS(sts, "m_mfxSession.SetHandle failed");

                          vaapiAllocatorParams *p_vaapiAllocParams = new vaapiAllocatorParams;
                          MSDK_CHECK_POINTER(p_vaapiAllocParams, MFX_ERR_MEMORY_ALLOC);

                          p_vaapiAllocParams->m_dpy = va_dpy;
                          if (m_eWorkMode == MODE_RENDERING) {
                              if (m_libvaBackend == MFX_LIBVA_DRM_MODESET) {
                                  CVAAPIDeviceDRM* drmdev = dynamic_cast&ltCVAAPIDeviceDRM*&gt(m_hwdev);
                                  p_vaapiAllocParams->m_export_mode = vaapiAllocatorParams::CUSTOM_FLINK;
                                  p_vaapiAllocParams->m_exporter = dynamic_cast&ltvaapiAllocatorParams::Exporter*&gt(drmdev->getRenderer());
                              } else if (m_libvaBackend == MFX_LIBVA_WAYLAND || m_libvaBackend == MFX_LIBVA_X11) {
                                  p_vaapiAllocParams->m_export_mode = vaapiAllocatorParams::PRIME;
                              }
                          }
                          m_export_mode = p_vaapiAllocParams->m_export_mode;
                          m_pmfxAllocatorParams = p_vaapiAllocParams;

                          /* In case of video memory we must provide MediaSDK with external allocator
                          thus we demonstrate "external allocator" usage model.
                          Call SetAllocator to pass allocator to mediasdk */
                          sts = m_mfxSession.SetFrameAllocator(m_pGeneralAllocator);
                          MSDK_CHECK_STATUS(sts, "m_mfxSession.SetFrameAllocator failed");

                          m_bExternalAlloc = true;
                    #endif
                      }
                      else
                      {
                    #ifdef LIBVA_SUPPORT
                          //in case of system memory allocator we also have to pass MFX_HANDLE_VA_DISPLAY to HW library

                          if(MFX_IMPL_HARDWARE == MFX_IMPL_BASETYPE(m_impl))
                          {
                              sts = CreateHWDevice();
                              MSDK_CHECK_STATUS(sts, "CreateHWDevice failed");

                              // provide device manager to MediaSDK
                              VADisplay va_dpy = NULL;
                              sts = m_hwdev->GetHandle(MFX_HANDLE_VA_DISPLAY, (mfxHDL *)&va_dpy);
                              MSDK_CHECK_STATUS(sts, "m_hwdev->GetHandle failed");
                              sts = m_mfxSession.SetHandle(MFX_HANDLE_VA_DISPLAY, va_dpy);
                              MSDK_CHECK_STATUS(sts, "m_mfxSession.SetHandle failed");
                          }
                    #endif
                          // create system memory allocator
                          //m_pGeneralAllocator = new SysMemFrameAllocator;
                          //MSDK_CHECK_POINTER(m_pGeneralAllocator, MFX_ERR_MEMORY_ALLOC);

                          /* In case of system memory we demonstrate "no external allocator" usage model.
                          We don't call SetAllocator, MediaSDK uses internal allocator.
                          We use system memory allocator simply as a memory manager for application*/
                      }

                      // initialize memory allocator
                      sts = m_pGeneralAllocator->Init(m_pmfxAllocatorParams);
                      MSDK_CHECK_STATUS(sts, "m_pGeneralAllocator->Init failed");

                      return MFX_ERR_NONE;
                    }

                  </ui-codemirror>
                </div>
            </div>
        </div>
    </div>

    <div class="row">
        <div class="col-lg-12">
            <div ibox title="Delete frames and allocator">
                <div content-block name="xdk-issues" message="Check after completing this section">
                  <ui-codemirror ui-codemirror-opts="editorOptions" id="topic-configure">
                    void CDecodingPipeline::DeleteFrames()
                    {
                      FreeBuffers();

                      m_pCurrentFreeSurface = NULL;
                      MSDK_SAFE_FREE(m_pCurrentFreeOutputSurface);

                      m_pCurrentFreeVppSurface = NULL;

                      // delete frames
                      if (m_pGeneralAllocator)
                      {
                          m_pGeneralAllocator->Free(m_pGeneralAllocator->pthis, &m_mfxResponse);
                      }

                      return;
                    }

                    void CDecodingPipeline::DeleteAllocator()
                    {
                      // delete allocator
                      MSDK_SAFE_DELETE(m_pGeneralAllocator);
                      MSDK_SAFE_DELETE(m_pmfxAllocatorParams);
                      MSDK_SAFE_DELETE(m_hwdev);
                    }

                    void CDecodingPipeline::SetMultiView()
                    {
                      m_FileWriter.SetMultiView();
                      m_bIsMVC = true;
                    }

                  </ui-codemirror>
                </div>
            </div>
        </div>
    </div>

    <div class="row">
        <div class="col-lg-12">
            <div ibox title="Allocate and delete external buffer. Attach external parameters">
                <div content-block name="xdk-issues" message="Check after completing this section">
                  <ui-codemirror ui-codemirror-opts="editorOptions" id="topic-configure">
                    // function for allocating a specific external buffer
                    template &lttypename Buffer&gt
                    mfxStatus CDecodingPipeline::AllocateExtBuffer()
                    {
                      std::auto_ptr&ltBuffer&gt pExtBuffer (new Buffer());
                      if (!pExtBuffer.get())
                          return MFX_ERR_MEMORY_ALLOC;

                      init_ext_buffer(*pExtBuffer);

                      m_ExtBuffers.push_back(reinterpret_cast&ltmfxExtBuffer*&gt(pExtBuffer.release()));

                      return MFX_ERR_NONE;
                    }

                    void CDecodingPipeline::AttachExtParam()
                    {
                      m_mfxVideoParams.ExtParam = reinterpret_cast&ltmfxExtBuffer**&gt(&m_ExtBuffers[0]);
                      m_mfxVideoParams.NumExtParam = static_cast&ltmfxU16&gt(m_ExtBuffers.size());
                    }

                    void CDecodingPipeline::DeleteExtBuffers()
                    {
                      for (std::vector&ltmfxExtBuffer *&gt::iterator it = m_ExtBuffers.begin(); it != m_ExtBuffers.end(); ++it)
                          delete *it;
                      m_ExtBuffers.clear();
                    }

                  </ui-codemirror>
                </div>
            </div>
        </div>
    </div>

    <div class="row">
        <div class="col-lg-12">
            <div ibox title="Allocate and deallocate External MVC Buffers ">
                <div content-block name="xdk-issues" message="Check after completing this section">
                  <ui-codemirror ui-codemirror-opts="editorOptions" id="topic-configure">
                    mfxStatus CDecodingPipeline::AllocateExtMVCBuffers()
                    {
                        mfxU32 i;

                        mfxExtMVCSeqDesc* pExtMVCBuffer = (mfxExtMVCSeqDesc*) m_mfxVideoParams.ExtParam[0];
                        MSDK_CHECK_POINTER(pExtMVCBuffer, MFX_ERR_MEMORY_ALLOC);

                        pExtMVCBuffer->View = new mfxMVCViewDependency[pExtMVCBuffer->NumView];
                        MSDK_CHECK_POINTER(pExtMVCBuffer->View, MFX_ERR_MEMORY_ALLOC);
                        for (i = 0; i &lt pExtMVCBuffer->NumView; ++i)
                        {
                            MSDK_ZERO_MEMORY(pExtMVCBuffer->View[i]);
                        }
                        pExtMVCBuffer->NumViewAlloc = pExtMVCBuffer->NumView;

                        pExtMVCBuffer->ViewId = new mfxU16[pExtMVCBuffer->NumViewId];
                        MSDK_CHECK_POINTER(pExtMVCBuffer->ViewId, MFX_ERR_MEMORY_ALLOC);
                        for (i = 0; i &lt pExtMVCBuffer->NumViewId; ++i)
                        {
                            MSDK_ZERO_MEMORY(pExtMVCBuffer->ViewId[i]);
                        }
                        pExtMVCBuffer->NumViewIdAlloc = pExtMVCBuffer->NumViewId;

                        pExtMVCBuffer->OP = new mfxMVCOperationPoint[pExtMVCBuffer->NumOP];
                        MSDK_CHECK_POINTER(pExtMVCBuffer->OP, MFX_ERR_MEMORY_ALLOC);
                        for (i = 0; i &lt pExtMVCBuffer->NumOP; ++i)
                        {
                            MSDK_ZERO_MEMORY(pExtMVCBuffer->OP[i]);
                        }
                        pExtMVCBuffer->NumOPAlloc = pExtMVCBuffer->NumOP;

                        return MFX_ERR_NONE;
                    }

                    void CDecodingPipeline::DeallocateExtMVCBuffers()
                    {
                        mfxExtMVCSeqDesc* pExtMVCBuffer = (mfxExtMVCSeqDesc*) m_mfxVideoParams.ExtParam[0];
                        if (pExtMVCBuffer != NULL)
                        {
                            MSDK_SAFE_DELETE_ARRAY(pExtMVCBuffer->View);
                            MSDK_SAFE_DELETE_ARRAY(pExtMVCBuffer->ViewId);
                            MSDK_SAFE_DELETE_ARRAY(pExtMVCBuffer->OP);
                        }

                        MSDK_SAFE_DELETE(m_mfxVideoParams.ExtParam[0]);

                        m_bIsExtBuffers = false;
                    }
                  </ui-codemirror>
                </div>
            </div>
        </div>
    </div>

    <div class="row">
        <div class="col-lg-12">
            <div ibox title="Reset Decoder">
                <div content-block name="xdk-issues" message="Check after completing this section">
                  <ui-codemirror ui-codemirror-opts="editorOptions" id="topic-configure">
                    mfxStatus CDecodingPipeline::ResetDecoder(sInputParams *pParams)
                    {
                      mfxStatus sts = MFX_ERR_NONE;

                      // close decoder
                      sts = m_pmfxDEC->Close();
                      MSDK_IGNORE_MFX_STS(sts, MFX_ERR_NOT_INITIALIZED);
                      MSDK_CHECK_STATUS(sts, "m_pmfxDEC->Close failed");

                      // close VPP
                      if(m_pmfxVPP)
                      {
                          sts = m_pmfxVPP->Close();
                          MSDK_IGNORE_MFX_STS(sts, MFX_ERR_NOT_INITIALIZED);
                          MSDK_CHECK_STATUS(sts, "m_pmfxVPP->Close failed");
                      }

                      // free allocated frames
                      DeleteFrames();

                      // initialize parameters with values from parsed header
                      sts = InitMfxParams(pParams);
                      MSDK_CHECK_STATUS(sts, "InitMfxParams failed");

                      // in case of HW accelerated decode frames must be allocated prior to decoder initialization
                      sts = AllocFrames();
                      MSDK_CHECK_STATUS(sts, "AllocFrames failed");

                      // init decoder
                      sts = m_pmfxDEC->Init(&m_mfxVideoParams);
                      if (MFX_WRN_PARTIAL_ACCELERATION == sts)
                      {
                          msdk_printf(MSDK_STRING("WARNING: partial acceleration\n"));
                          MSDK_IGNORE_MFX_STS(sts, MFX_WRN_PARTIAL_ACCELERATION);
                      }
                      MSDK_CHECK_STATUS(sts, "m_pmfxDEC->Init failed");

                      if(m_pmfxVPP)
                      {
                          sts = m_pmfxVPP->Init(&m_mfxVppVideoParams);
                          if (MFX_WRN_PARTIAL_ACCELERATION == sts)
                          {
                              msdk_printf(MSDK_STRING("WARNING: partial acceleration\n"));
                              MSDK_IGNORE_MFX_STS(sts, MFX_WRN_PARTIAL_ACCELERATION);
                          }
                          MSDK_CHECK_STATUS(sts, "m_pmfxVPP->Init failed");
                      }

                      return MFX_ERR_NONE;
                    }

                  </ui-codemirror>
                </div>
            </div>
        </div>
    </div>

    <div class="row">
        <div class="col-lg-12">
            <div ibox title="Deliver output, loop and thread function">
                <div content-block name="xdk-issues" message="Check after completing this section">
                  <ui-codemirror ui-codemirror-opts="editorOptions" id="topic-configure">
                    mfxStatus CDecodingPipeline::DeliverOutput(mfxFrameSurface1* frame)
                    {
                      CAutoTimer timer_fwrite(m_tick_fwrite);

                      mfxStatus res = MFX_ERR_NONE, sts = MFX_ERR_NONE;

                      if (!frame) {
                          return MFX_ERR_NULL_PTR;
                      }


                      if (m_bResetFileWriter)
                      {
                          sts = m_FileWriter.Reset();
                          MSDK_CHECK_STATUS(sts, "");
                          m_bResetFileWriter = false;
                      }

                      if (m_bExternalAlloc) {
                          if (m_eWorkMode == MODE_FILE_DUMP) {
                              res = m_pGeneralAllocator->Lock(m_pGeneralAllocator->pthis, frame->Data.MemId, &(frame->Data));
                              if (MFX_ERR_NONE == res) {
                                  res = m_bOutI420 ? m_FileWriter.WriteNextFrameI420(frame)
                                      : m_FileWriter.WriteNextFrame(frame);
                                  sts = m_pGeneralAllocator->Unlock(m_pGeneralAllocator->pthis, frame->Data.MemId, &(frame->Data));
                              }
                              if ((MFX_ERR_NONE == res) && (MFX_ERR_NONE != sts)) {
                                  res = sts;
                              }
                          } else if (m_eWorkMode == MODE_RENDERING) {
                    #if D3D_SURFACES_SUPPORT
                              res = m_d3dRender.RenderFrame(frame, m_pGeneralAllocator);
                    #elif LIBVA_SUPPORT
                              res = m_hwdev->RenderFrame(frame, m_pGeneralAllocator);
                    #endif

                              while( m_delayTicks && (m_startTick + m_delayTicks > msdk_time_get_tick()) )
                              {
                                  MSDK_SLEEP(0);
                              };
                              m_startTick=msdk_time_get_tick();
                          }
                      }
                      else {
                          res = m_bOutI420 ? m_FileWriter.WriteNextFrameI420(frame)
                              : m_FileWriter.WriteNextFrame(frame);
                      }

                      return res;
                    }

                    mfxStatus CDecodingPipeline::DeliverLoop(void)
                    {
                      mfxStatus res = MFX_ERR_NONE;

                      while (!m_bStopDeliverLoop) {
                          m_pDeliverOutputSemaphore->Wait();
                          if (m_bStopDeliverLoop) {
                              continue;
                          }
                          if (MFX_ERR_NONE != m_error) {
                              continue;
                          }
                          msdkOutputSurface* pCurrentDeliveredSurface = m_DeliveredSurfacesPool.GetSurface();
                          if (!pCurrentDeliveredSurface) {
                              m_error = MFX_ERR_NULL_PTR;
                              continue;
                          }
                          mfxFrameSurface1* frame = &(pCurrentDeliveredSurface->surface->frame);

                          m_error = DeliverOutput(frame);
                          ReturnSurfaceToBuffers(pCurrentDeliveredSurface);

                          pCurrentDeliveredSurface = NULL;
                          ++m_output_count;
                          m_pDeliveredEvent->Signal();
                      }
                      return res;
                    }

                    unsigned int MFX_STDCALL CDecodingPipeline::DeliverThreadFunc(void* ctx)
                    {
                      CDecodingPipeline* pipeline = (CDecodingPipeline*)ctx;

                      mfxStatus sts;
                      sts = pipeline->DeliverLoop();

                      return 0;
                    }

                  </ui-codemirror>
                </div>
            </div>
        </div>
    </div>

    <div class="row">
        <div class="col-lg-12">
            <div ibox title="Print per frame statistics">
                <div content-block name="xdk-issues" message="Check after completing this section">
                  <ui-codemirror ui-codemirror-opts="editorOptions" id="topic-configure">
                    void CDecodingPipeline::PrintPerFrameStat(bool force)
                    {
                    #define MY_COUNT 1 // TODO: this will be cmd option
                    #define MY_THRESHOLD 10000.0
                      if ((!(m_output_count % MY_COUNT) && (m_eWorkMode != MODE_PERFORMANCE)) || force) {
                          double fps, fps_fread, fps_fwrite;

                          m_timer_overall.Sync();

                          fps = (m_tick_overall)? m_output_count/CTimer::ConvertToSeconds(m_tick_overall): 0.0;
                          fps_fread = (m_tick_fread)? m_output_count/CTimer::ConvertToSeconds(m_tick_fread): 0.0;
                          fps_fwrite = (m_tick_fwrite)? m_output_count/CTimer::ConvertToSeconds(m_tick_fwrite): 0.0;
                          // decoding progress
                          msdk_printf(MSDK_STRING("Frame number: %4d, fps: %0.3f, fread_fps: %0.3f, fwrite_fps: %.3f\r"),
                              m_output_count,
                              fps,
                              (fps_fread &lt MY_THRESHOLD)? fps_fread: 0.0,
                              (fps_fwrite &lt MY_THRESHOLD)? fps_fwrite: 0.0);
                          fflush(NULL);
                    #if D3D_SURFACES_SUPPORT
                          m_d3dRender.UpdateTitle(fps);
                    #elif LIBVA_SUPPORT
                          if (m_hwdev) m_hwdev->UpdateTitle(fps);
                    #endif
                      }
                    }

                  </ui-codemirror>
                </div>
            </div>
        </div>
    </div>

    <div class="row">
        <div class="col-lg-12">
            <div ibox title="Synchronize output surface">
                <div content-block name="xdk-issues" message="Check after completing this section">
                  <ui-codemirror ui-codemirror-opts="editorOptions" id="topic-configure">
                    mfxStatus CDecodingPipeline::SyncOutputSurface(mfxU32 wait)
                    {
                      if (!m_pCurrentOutputSurface) {
                          m_pCurrentOutputSurface = m_OutputSurfacesPool.GetSurface();
                      }
                      if (!m_pCurrentOutputSurface) {
                          return MFX_ERR_MORE_DATA;
                      }

                      mfxStatus sts = m_mfxSession.SyncOperation(m_pCurrentOutputSurface->syncp, wait);

                      if (MFX_WRN_IN_EXECUTION == sts) {
                          return sts;
                      }
                      if (MFX_ERR_NONE == sts) {
                          // we got completely decoded frame - pushing it to the delivering thread...
                          ++m_synced_count;
                          if (m_bPrintLatency) {
                              m_vLatency.push_back(m_timer_overall.Sync() - m_pCurrentOutputSurface->surface->submit);
                          }
                          else {
                              PrintPerFrameStat();
                          }

                          if (m_eWorkMode == MODE_PERFORMANCE) {
                              m_output_count = m_synced_count;
                              ReturnSurfaceToBuffers(m_pCurrentOutputSurface);
                          } else if (m_eWorkMode == MODE_FILE_DUMP) {
                              m_output_count = m_synced_count;
                              sts = DeliverOutput(&(m_pCurrentOutputSurface->surface->frame));
                              if (MFX_ERR_NONE != sts) {
                                  sts = MFX_ERR_UNKNOWN;
                              }
                              ReturnSurfaceToBuffers(m_pCurrentOutputSurface);
                          } else if (m_eWorkMode == MODE_RENDERING) {
                              m_DeliveredSurfacesPool.AddSurface(m_pCurrentOutputSurface);
                              m_pDeliveredEvent->Reset();
                              m_pDeliverOutputSemaphore->Post();
                          }
                          m_pCurrentOutputSurface = NULL;
                      }

                      if (MFX_ERR_NONE != sts) {
                          sts = MFX_ERR_UNKNOWN;
                      }

                      return sts;
                    }
                  </ui-codemirror>
                </div>
            </div>
        </div>
    </div>

    <div class="row">
        <div class="col-lg-12">
            <div ibox title="Run Decoding">
                <div content-block name="xdk-issues" message="Check after completing this section">
                  <ui-codemirror ui-codemirror-opts="editorOptions" id="topic-configure">
                    mfxStatus CDecodingPipeline::RunDecoding()
                    {
                      mfxFrameSurface1*   pOutSurface = NULL;
                      mfxBitstream*       pBitstream = &m_mfxBS;
                      mfxStatus           sts = MFX_ERR_NONE;
                      bool                bErrIncompatibleVideoParams = false;
                      CTimeInterval&lt&gt     decodeTimer(m_bIsCompleteFrame);
                      time_t start_time = time(0);
                      MSDKThread * pDeliverThread = NULL;

                      if (m_eWorkMode == MODE_RENDERING) {
                          m_pDeliverOutputSemaphore = new MSDKSemaphore(sts);
                          m_pDeliveredEvent = new MSDKEvent(sts, false, false);
                          pDeliverThread = new MSDKThread(sts, DeliverThreadFunc, this);
                          if (!pDeliverThread || !m_pDeliverOutputSemaphore || !m_pDeliveredEvent) {
                              MSDK_SAFE_DELETE(pDeliverThread);
                              MSDK_SAFE_DELETE(m_pDeliverOutputSemaphore);
                              MSDK_SAFE_DELETE(m_pDeliveredEvent);
                              return MFX_ERR_MEMORY_ALLOC;
                          }
                      }

                      if (MFX_CODEC_CAPTURE == this->m_mfxVideoParams.mfx.CodecId)
                      {
                          pBitstream = 0;
                      }

                      while (((sts == MFX_ERR_NONE) || (MFX_ERR_MORE_DATA == sts) || (MFX_ERR_MORE_SURFACE == sts)) && (m_nFrames &gt m_output_count)){
                          if (MFX_ERR_NONE != m_error) {
                              msdk_printf(MSDK_STRING("DeliverOutput return error = %d\n"),m_error);
                              break;
                          }

                          if (pBitstream && ((MFX_ERR_MORE_DATA == sts) || (m_bIsCompleteFrame && !pBitstream->DataLength))) {
                              CAutoTimer timer_fread(m_tick_fread);
                              sts = m_FileReader->ReadNextFrame(pBitstream); // read more data to input bit stream

                              if (MFX_ERR_MORE_DATA == sts) {
                                  sts = MFX_ERR_NONE;
                                  // Timeout has expired or videowall mode
                                  if ( ((CTimer::ConvertToSeconds(m_tick_overall) &lt m_nTimeout) && m_nTimeout ) || m_bIsVideoWall)
                                  {
                                      m_FileReader->Reset();
                                      m_bResetFileWriter = true;
                                      continue;
                                  }

                                  // we almost reached end of stream, need to pull buffered data now
                                  pBitstream = NULL;
                              }
                          }
                          if ((MFX_ERR_NONE == sts) || (MFX_ERR_MORE_DATA == sts) || (MFX_ERR_MORE_SURFACE == sts)) {
                              // here we check whether output is ready, though we do not wait...
                    #ifndef __SYNC_WA
                              mfxStatus _sts = SyncOutputSurface(0);
                              if (MFX_ERR_UNKNOWN == _sts) {
                                  sts = _sts;
                                  break;
                              } else if (MFX_ERR_NONE == _sts) {
                                  continue;
                              }
                    #endif
                          }
                          if ((MFX_ERR_NONE == sts) || (MFX_ERR_MORE_DATA == sts) || (MFX_ERR_MORE_SURFACE == sts)) {
                              SyncFrameSurfaces();
                              SyncVppFrameSurfaces();
                              if (!m_pCurrentFreeSurface) {
                                  m_pCurrentFreeSurface = m_FreeSurfacesPool.GetSurface();
                              }
                              if (!m_pCurrentFreeVppSurface) {
                                m_pCurrentFreeVppSurface = m_FreeVppSurfacesPool.GetSurface();
                              }
                    #ifndef __SYNC_WA
                              if (!m_pCurrentFreeSurface || !m_pCurrentFreeVppSurface) {
                    #else
                              if (!m_pCurrentFreeSurface || (!m_pCurrentFreeVppSurface && m_bVppIsUsed) || (m_OutputSurfacesPool.GetSurfaceCount() == m_mfxVideoParams.AsyncDepth)) {
                    #endif
                                  // we stuck with no free surface available, now we will sync...
                                  sts = SyncOutputSurface(MSDK_DEC_WAIT_INTERVAL);
                                  if (MFX_ERR_MORE_DATA == sts) {
                                      if ((m_eWorkMode == MODE_PERFORMANCE) || (m_eWorkMode == MODE_FILE_DUMP)) {
                                          sts = MFX_ERR_NOT_FOUND;
                                      } else if (m_eWorkMode == MODE_RENDERING) {
                                          if (m_synced_count != m_output_count) {
                                              sts = m_pDeliveredEvent->TimedWait(MSDK_DEC_WAIT_INTERVAL);
                                          } else {
                                              sts = MFX_ERR_NOT_FOUND;
                                          }
                                      }
                                      if (MFX_ERR_NOT_FOUND == sts) {
                                          msdk_printf(MSDK_STRING("fatal: failed to find output surface, that's a bug!\n"));
                                          break;
                                      }
                                  }
                                  // note: MFX_WRN_IN_EXECUTION will also be treated as an error at this point
                                  continue;
                              }

                              if (!m_pCurrentFreeOutputSurface) {
                                  m_pCurrentFreeOutputSurface = GetFreeOutputSurface();
                              }
                              if (!m_pCurrentFreeOutputSurface) {
                                  sts = MFX_ERR_NOT_FOUND;
                                  break;
                              }
                          }

                          // exit by timeout
                          if ((MFX_ERR_NONE == sts) && m_bIsVideoWall && (time(0)-start_time) &gt= m_nTimeout) {
                              sts = MFX_ERR_NONE;
                              break;
                          }

                          if ((MFX_ERR_NONE == sts) || (MFX_ERR_MORE_DATA == sts) || (MFX_ERR_MORE_SURFACE == sts)) {
                              if (m_bIsCompleteFrame) {
                                  m_pCurrentFreeSurface->submit = m_timer_overall.Sync();
                              }
                              pOutSurface = NULL;
                              do {
                                  sts = m_pmfxDEC->DecodeFrameAsync(pBitstream, &(m_pCurrentFreeSurface->frame), &pOutSurface, &(m_pCurrentFreeOutputSurface->syncp));
                                  if (pBitstream && MFX_ERR_MORE_DATA == sts && pBitstream->MaxLength == pBitstream->DataLength)
                                  {
                                      mfxStatus sts = ExtendMfxBitstream(pBitstream, pBitstream->MaxLength * 2);
                                      MSDK_CHECK_STATUS_SAFE(sts, "ExtendMfxBitstream failed", MSDK_SAFE_DELETE(pDeliverThread));
                                  }

                                  if (MFX_WRN_DEVICE_BUSY == sts) {
                                      if (m_bIsCompleteFrame) {
                                          //in low latency mode device busy leads to increasing of latency
                                          //msdk_printf(MSDK_STRING("Warning : latency increased due to MFX_WRN_DEVICE_BUSY\n"));
                                      }
                                      mfxStatus _sts = SyncOutputSurface(MSDK_DEC_WAIT_INTERVAL);
                                      // note: everything except MFX_ERR_NONE are errors at this point
                                      if (MFX_ERR_NONE == _sts) {
                                          sts = MFX_WRN_DEVICE_BUSY;
                                      } else {
                                          sts = _sts;
                                          if (MFX_ERR_MORE_DATA == sts) {
                                              // we can't receive MFX_ERR_MORE_DATA and have no output - that's a bug
                                              sts = MFX_WRN_DEVICE_BUSY;//MFX_ERR_NOT_FOUND;
                                          }
                                      }
                                  }
                              } while (MFX_WRN_DEVICE_BUSY == sts);

                              if (sts &gt MFX_ERR_NONE) {
                                  // ignoring warnings...
                                  if (m_pCurrentFreeOutputSurface->syncp) {
                                      MSDK_SELF_CHECK(pOutSurface);
                                      // output is available
                                      sts = MFX_ERR_NONE;
                                  } else {
                                      // output is not available
                                      sts = MFX_ERR_MORE_SURFACE;
                                  }
                              } else if ((MFX_ERR_MORE_DATA == sts) && pBitstream) {
                                  if (m_bIsCompleteFrame && pBitstream->DataLength)
                                  {
                                      // In low_latency mode decoder have to process bitstream completely
                                      msdk_printf(MSDK_STRING("error: Incorrect decoder behavior in low latency mode (bitstream length is not equal to 0 after decoding)\n"));
                                      sts = MFX_ERR_UNDEFINED_BEHAVIOR;
                                      continue;
                                  }
                              } else if ((MFX_ERR_MORE_DATA == sts) && !pBitstream) {
                                  // that's it - we reached end of stream; now we need to render bufferred data...
                                  do {
                                      sts = SyncOutputSurface(MSDK_DEC_WAIT_INTERVAL);
                                  } while (MFX_ERR_NONE == sts);

                                  while (m_synced_count != m_output_count) {
                                      m_pDeliveredEvent->Wait();
                                  }

                                  if (MFX_ERR_MORE_DATA == sts) {
                                      sts = MFX_ERR_NONE;
                                  }
                                  break;
                              } else if (MFX_ERR_INCOMPATIBLE_VIDEO_PARAM == sts) {
                                  bErrIncompatibleVideoParams = true;
                                  // need to go to the buffering loop prior to reset procedure
                                  pBitstream = NULL;
                                  sts = MFX_ERR_NONE;
                                  continue;
                              }
                          }

                          if ((MFX_ERR_NONE == sts) || (MFX_ERR_MORE_DATA == sts) || (MFX_ERR_MORE_SURFACE == sts)) {
                              // if current free surface is locked we are moving it to the used surfaces array
                              /*if (m_pCurrentFreeSurface->frame.Data.Locked)*/ {
                                  m_UsedSurfacesPool.AddSurface(m_pCurrentFreeSurface);
                                  m_pCurrentFreeSurface = NULL;
                              }
                          }
                          if (MFX_ERR_NONE == sts)
                          {
                              if (m_bVppIsUsed)
                              {
                                  if(m_pCurrentFreeVppSurface)
                                  {
                                      do
                                      {
                                          if ((m_pCurrentFreeVppSurface->frame.Info.CropW == 0) ||
                                              (m_pCurrentFreeVppSurface->frame.Info.CropH == 0)) {
                                                  m_pCurrentFreeVppSurface->frame.Info.CropW = pOutSurface->Info.CropW;
                                                  m_pCurrentFreeVppSurface->frame.Info.CropH = pOutSurface->Info.CropH;
                                                  m_pCurrentFreeVppSurface->frame.Info.CropX = pOutSurface->Info.CropX;
                                                  m_pCurrentFreeVppSurface->frame.Info.CropY = pOutSurface->Info.CropY;
                                          }
                                          if (pOutSurface->Info.PicStruct != m_pCurrentFreeVppSurface->frame.Info.PicStruct) {
                                              m_pCurrentFreeVppSurface->frame.Info.PicStruct = pOutSurface->Info.PicStruct;
                                          }
                                          if ((pOutSurface->Info.PicStruct == 0) && (m_pCurrentFreeVppSurface->frame.Info.PicStruct == 0)) {
                                              m_pCurrentFreeVppSurface->frame.Info.PicStruct = pOutSurface->Info.PicStruct = MFX_PICSTRUCT_PROGRESSIVE;
                                          }

                                          if (m_diMode && m_pCurrentFreeVppSurface)
                                              m_pCurrentFreeVppSurface->frame.Info.PicStruct = MFX_PICSTRUCT_PROGRESSIVE;

                                          // WA: RunFrameVPPAsync doesn't copy ViewId from input to output
                                          m_pCurrentFreeVppSurface->frame.Info.FrameId.ViewId = pOutSurface->Info.FrameId.ViewId;
                                          sts = m_pmfxVPP->RunFrameVPPAsync(pOutSurface, &(m_pCurrentFreeVppSurface->frame), NULL, &(m_pCurrentFreeOutputSurface->syncp));

                                          if (MFX_WRN_DEVICE_BUSY == sts) {
                                              MSDK_SLEEP(1); // just wait and then repeat the same call to RunFrameVPPAsync
                                          }
                                      } while (MFX_WRN_DEVICE_BUSY == sts);

                                      // process errors
                                      if (MFX_ERR_MORE_DATA == sts) { // will never happen actually
                                          continue;
                                      }
                                      else if (MFX_ERR_NONE != sts) {
                                          break;
                                      }

                                      m_UsedVppSurfacesPool.AddSurface(m_pCurrentFreeVppSurface);
                                      msdk_atomic_inc16(&(m_pCurrentFreeVppSurface->render_lock));

                                      m_pCurrentFreeOutputSurface->surface = m_pCurrentFreeVppSurface;
                                      m_OutputSurfacesPool.AddSurface(m_pCurrentFreeOutputSurface);

                                      m_pCurrentFreeOutputSurface = NULL;
                                      m_pCurrentFreeVppSurface = NULL;
                                  }
                              }
                              else
                              {
                                  msdkFrameSurface* surface = FindUsedSurface(pOutSurface);

                                  msdk_atomic_inc16(&(surface->render_lock));

                                  m_pCurrentFreeOutputSurface->surface = surface;
                                  m_OutputSurfacesPool.AddSurface(m_pCurrentFreeOutputSurface);
                                  m_pCurrentFreeOutputSurface = NULL;
                              }
                          }
                      } //while processing

                      PrintPerFrameStat(true);

                      if (m_bPrintLatency && m_vLatency.size() &gt 0) {
                          unsigned int frame_idx = 0;
                          msdk_tick sum = 0;
                          for (std::vector&ltmsdk_tick&gt::iterator it = m_vLatency.begin(); it != m_vLatency.end(); ++it)
                          {
                              sum += *it;
                              msdk_printf(MSDK_STRING("Frame %4d, latency=%5.5f ms\n"), ++frame_idx, CTimer::ConvertToSeconds(*it)*1000);
                          }
                          msdk_printf(MSDK_STRING("\nLatency summary:\n"));
                          msdk_printf(MSDK_STRING("\nAVG=%5.5f ms, MAX=%5.5f ms, MIN=%5.5f ms"),
                              CTimer::ConvertToSeconds((msdk_tick)((mfxF64)sum/m_vLatency.size()))*1000,
                              CTimer::ConvertToSeconds(*std::max_element(m_vLatency.begin(), m_vLatency.end()))*1000,
                              CTimer::ConvertToSeconds(*std::min_element(m_vLatency.begin(), m_vLatency.end()))*1000);
                      }

                      if (m_eWorkMode == MODE_RENDERING) {
                          m_bStopDeliverLoop = true;
                          m_pDeliverOutputSemaphore->Post();
                          if (pDeliverThread)
                              pDeliverThread->Wait();
                      }

                      MSDK_SAFE_DELETE(m_pDeliverOutputSemaphore);
                      MSDK_SAFE_DELETE(m_pDeliveredEvent);
                      MSDK_SAFE_DELETE(pDeliverThread);

                      // exit in case of other errors
                      MSDK_CHECK_STATUS(sts, "Unexpected error!!");

                      // if we exited main decoding loop with ERR_INCOMPATIBLE_PARAM we need to send this status to caller
                      if (bErrIncompatibleVideoParams) {
                          sts = MFX_ERR_INCOMPATIBLE_VIDEO_PARAM;
                      }

                      return sts; // ERR_NONE or ERR_INCOMPATIBLE_VIDEO_PARAM
                    }
                  </ui-codemirror>
                </div>
            </div>
        </div>
    </div>

    <div class="row">
        <div class="col-lg-12">
            <div ibox title="Print Information">
                <div content-block name="xdk-issues" message="Check after completing this section">
                  <ui-codemirror ui-codemirror-opts="editorOptions" id="topic-configure">
                    void CDecodingPipeline::PrintInfo()
                    {
                      msdk_printf(MSDK_STRING("Decoding Sample Version %s\n\n"), MSDK_SAMPLE_VERSION);
                      msdk_printf(MSDK_STRING("\nInput video\t%s\n"), CodecIdToStr(m_mfxVideoParams.mfx.CodecId).c_str());
                      if (m_bVppIsUsed)
                      {
                          msdk_printf(MSDK_STRING("Output format\t%s (using vpp)\n"), CodecIdToStr(m_mfxVppVideoParams.vpp.Out.FourCC).c_str());
                      }
                      else
                      {
                          msdk_printf(MSDK_STRING("Output format\t%s\n"), CodecIdToStr(m_mfxVideoParams.mfx.FrameInfo.FourCC).c_str());
                      }

                      mfxFrameInfo Info = m_mfxVideoParams.mfx.FrameInfo;
                      msdk_printf(MSDK_STRING("Input:\n"));
                      msdk_printf(MSDK_STRING("  Resolution\t%dx%d\n"), Info.Width, Info.Height);
                      msdk_printf(MSDK_STRING("  Crop X,Y,W,H\t%d,%d,%d,%d\n"), Info.CropX, Info.CropY, Info.CropW, Info.CropH);
                      msdk_printf(MSDK_STRING("Output:\n"));
                      if (m_vppOutHeight && m_vppOutWidth)
                      {
                          msdk_printf(MSDK_STRING("  Resolution\t%dx%d\n"), m_vppOutWidth, m_vppOutHeight);
                      }
                      else
                      {
                          msdk_printf(MSDK_STRING("  Resolution\t%dx%d\n"), Info.Width, Info.Height);
                      }

                      mfxF64 dFrameRate = CalculateFrameRate(Info.FrameRateExtN, Info.FrameRateExtD);
                      msdk_printf(MSDK_STRING("Frame rate\t%.2f\n"), dFrameRate);

                      const msdk_char* sMemType =
                    #if defined(_WIN32) || defined(_WIN64)
                          m_memType == D3D9_MEMORY  ? MSDK_STRING("d3d")
                    #else
                          m_memType == D3D9_MEMORY  ? MSDK_STRING("vaapi")
                    #endif
                          : (m_memType == D3D11_MEMORY ? MSDK_STRING("d3d11")
                          : MSDK_STRING("system"));
                      msdk_printf(MSDK_STRING("Memory type\t\t%s\n"), sMemType);


                      const msdk_char* sImpl = (MFX_IMPL_VIA_D3D11 == MFX_IMPL_VIA_MASK(m_impl)) ? MSDK_STRING("hw_d3d11")
                                             : (MFX_IMPL_SOFTWARE == MFX_IMPL_BASETYPE(m_impl))  ? MSDK_STRING("sw")
                                                                           : MSDK_STRING("hw");
                      msdk_printf(MSDK_STRING("MediaSDK impl\t\t%s\n"), sImpl);

                      mfxVersion ver;
                      m_mfxSession.QueryVersion(&ver);
                      msdk_printf(MSDK_STRING("MediaSDK version\t%d.%d\n"), ver.Major, ver.Minor);

                      msdk_printf(MSDK_STRING("\n"));

                      return;
                    }

                  </ui-codemirror>
                </div>
            </div>
        </div>
    </div>

    <div class="row">
        <div class="col-lg-12">
            <div ibox title="Write the following code in pipeline_decode.h">
                <div content-block name="xdk-issues" message="Check after completing this section">
                  <ui-codemirror ui-codemirror-opts="editorOptions" id="topic-configure">
                    #ifndef __PIPELINE_DECODE_H__
                    #define __PIPELINE_DECODE_H__

                    #include "sample_defs.h"

                    #if D3D_SURFACES_SUPPORT
                    #pragma warning(disable : 4201)
                    #include &ltd3d9.h&gt
                    #include &ltdxva2api.h&gt
                    #endif

                    #include &ltvector&gt
                    #include "hw_device.h"
                    #include "decode_render.h"
                    #include "mfx_buffering.h"
                    #include &ltmemory&gt

                    #include "sample_utils.h"
                    #include "sample_params.h"
                    #include "base_allocator.h"

                    #include "mfxmvc.h"
                    #include "mfxjpeg.h"
                    #include "mfxplugin.h"
                    #include "mfxplugin++.h"
                    #include "mfxvideo.h"
                    #include "mfxvideo++.h"
                    #include "mfxvp8.h"

                    #include "plugin_loader.h"
                    #include "general_allocator.h"

                    enum MemType {
                      SYSTEM_MEMORY = 0x00,
                      D3D9_MEMORY   = 0x01,
                      D3D11_MEMORY  = 0x02,
                    };

                    enum eWorkMode {
                    MODE_PERFORMANCE,
                    MODE_RENDERING,
                    MODE_FILE_DUMP
                    };

                    struct sInputParams
                    {
                      mfxU32 videoType;
                      eWorkMode mode;
                      MemType memType;
                      bool    bUseHWLib; // true if application wants to use HW mfx library
                      bool    bIsMVC; // true if Multi-View Codec is in use
                      bool    bLowLat; // low latency mode
                      bool    bCalLat; // latency calculation
                      bool    bUseFullColorRange; //whether to use full color range
                      mfxU16  nMaxFPS; //rendering limited by certain fps
                      mfxU32  nWallCell;
                      mfxU32  nWallW; //number of windows located in each row
                      mfxU32  nWallH; //number of windows located in each column
                      mfxU32  nWallMonitor; //monitor id, 0,1,.. etc
                      bool    bWallNoTitle; //whether to show title for each window with fps value

                      mfxU32  numViews; // number of views for Multi-View Codec
                      mfxU32  nRotation; // rotation for Motion JPEG Codec
                      mfxU16  nAsyncDepth; // asyncronous queue
                      mfxU16  nTimeout; // timeout in seconds
                      mfxU16  gpuCopy; // GPU Copy mode (three-state option)
                      mfxU16  nThreadsNum;
                      mfxI32  SchedulingType;
                      mfxI32  Priority;

                      mfxU16  scrWidth;
                      mfxU16  scrHeight;

                      mfxU16  Width;
                      mfxU16  Height;

                      mfxU32  fourcc;
                      mfxU16  chromaType;
                      mfxU32  nFrames;
                      mfxU16  eDeinterlace;
                      bool    outI420;

                      bool    bPerfMode;
                      bool    bRenderWin;
                      mfxU32  nRenderWinX;
                      mfxU32  nRenderWinY;

                      mfxI32  monitorType;
                    #if defined(LIBVA_SUPPORT)
                      mfxI32  libvaBackend;
                    #endif // defined(MFX_LIBVA_SUPPORT)

                      msdk_char     strSrcFile[MSDK_MAX_FILENAME_LEN];
                      msdk_char     strDstFile[MSDK_MAX_FILENAME_LEN];
                      sPluginParams pluginParams;

                      sInputParams()
                      {
                          MSDK_ZERO_MEMORY(*this);
                      }
                    };

                    template&lt&gtstruct mfx_ext_buffer_id&ltmfxExtMVCSeqDesc&gt{
                      enum {id = MFX_EXTBUFF_MVC_SEQ_DESC};
                    };

                    struct CPipelineStatistics
                    {
                      CPipelineStatistics():
                          m_input_count(0),
                          m_output_count(0),
                          m_synced_count(0),
                          m_tick_overall(0),
                          m_tick_fread(0),
                          m_tick_fwrite(0),
                          m_timer_overall(m_tick_overall)
                      {
                      }
                      virtual ~CPipelineStatistics(){}

                      mfxU32 m_input_count;     // number of received incoming packets (frames or bitstreams)
                      mfxU32 m_output_count;    // number of delivered outgoing packets (frames or bitstreams)
                      mfxU32 m_synced_count;

                      msdk_tick m_tick_overall; // overall time passed during processing
                      msdk_tick m_tick_fread;   // part of tick_overall: time spent to receive incoming data
                      msdk_tick m_tick_fwrite;  // part of tick_overall: time spent to deliver outgoing data

                      CAutoTimer m_timer_overall; // timer which corresponds to m_tick_overall

                    private:
                      CPipelineStatistics(const CPipelineStatistics&);
                      void operator=(const CPipelineStatistics&);
                    };

                    class CDecodingPipeline:
                      public CBuffering,
                      public CPipelineStatistics
                    {
                    public:
                      CDecodingPipeline();
                      virtual ~CDecodingPipeline();

                      virtual mfxStatus Init(sInputParams *pParams);
                      virtual mfxStatus RunDecoding();
                      virtual void Close();
                      virtual mfxStatus ResetDecoder(sInputParams *pParams);
                      virtual mfxStatus ResetDevice();

                      void SetMultiView();
                      void SetExtBuffersFlag()       { m_bIsExtBuffers = true; }
                      virtual void PrintInfo();

                    protected: // functions
                      virtual mfxStatus CreateRenderingWindow(sInputParams *pParams, bool try_s3d);
                      virtual mfxStatus InitMfxParams(sInputParams *pParams);

                      // function for allocating a specific external buffer
                      template &lttypename Buffer&gt
                      mfxStatus AllocateExtBuffer();
                      virtual void DeleteExtBuffers();

                      virtual mfxStatus AllocateExtMVCBuffers();
                      virtual void    DeallocateExtMVCBuffers();

                      virtual void AttachExtParam();

                      virtual mfxStatus InitVppParams();
                      virtual mfxStatus AllocAndInitVppFilters();
                      virtual bool IsVppRequired(sInputParams *pParams);

                      virtual mfxStatus CreateAllocator();
                      virtual mfxStatus CreateHWDevice();
                      virtual mfxStatus AllocFrames();
                      virtual void DeleteFrames();
                      virtual void DeleteAllocator();

                      /** \brief Performs SyncOperation on the current output surface with the specified timeout.
                       *
                       * @return MFX_ERR_NONE Output surface was successfully synced and delivered.
                       * @return MFX_ERR_MORE_DATA Array of output surfaces is empty, need to feed decoder.
                       * @return MFX_WRN_IN_EXECUTION Specified timeout have elapsed.
                       * @return MFX_ERR_UNKNOWN An error has occurred.
                       */
                      virtual mfxStatus SyncOutputSurface(mfxU32 wait);
                      virtual mfxStatus DeliverOutput(mfxFrameSurface1* frame);
                      virtual void PrintPerFrameStat(bool force = false);

                      virtual mfxStatus DeliverLoop(void);

                      static unsigned int MFX_STDCALL DeliverThreadFunc(void* ctx);

                    protected: // variables
                      CSmplYUVWriter          m_FileWriter;
                      std::auto_ptr&ltCSmplBitstreamReader&gt  m_FileReader;
                      mfxBitstream            m_mfxBS; // contains encoded data

                      MFXVideoSession         m_mfxSession;
                      mfxIMPL                 m_impl;
                      MFXVideoDECODE*         m_pmfxDEC;
                      MFXVideoVPP*            m_pmfxVPP;
                      mfxVideoParam           m_mfxVideoParams;
                      mfxVideoParam           m_mfxVppVideoParams;
                      std::auto_ptr&ltMFXVideoUSER&gt  m_pUserModule;
                      std::auto_ptr&ltMFXPlugin&gt m_pPlugin;
                      std::vector&ltmfxExtBuffer *&gt m_ExtBuffers;

                      GeneralAllocator*       m_pGeneralAllocator;
                      mfxAllocatorParams*     m_pmfxAllocatorParams;
                      MemType                 m_memType;      // memory type of surfaces to use
                      bool                    m_bExternalAlloc; // use memory allocator as external for Media SDK
                      bool                    m_bDecOutSysmem; // use system memory between Decoder and VPP, if false - video memory
                      mfxFrameAllocResponse   m_mfxResponse; // memory allocation response for decoder
                      mfxFrameAllocResponse   m_mfxVppResponse;   // memory allocation response for vpp

                      msdkFrameSurface*       m_pCurrentFreeSurface; // surface detached from free surfaces array
                      msdkFrameSurface*       m_pCurrentFreeVppSurface; // VPP surface detached from free VPP surfaces array
                      msdkOutputSurface*      m_pCurrentFreeOutputSurface; // surface detached from free output surfaces array
                      msdkOutputSurface*      m_pCurrentOutputSurface; // surface detached from output surfaces array

                      MSDKSemaphore*          m_pDeliverOutputSemaphore; // to access to DeliverOutput method
                      MSDKEvent*              m_pDeliveredEvent; // to signal when output surfaces will be processed
                      mfxStatus               m_error; // error returned by DeliverOutput method
                      bool                    m_bStopDeliverLoop;

                      eWorkMode               m_eWorkMode; // work mode for the pipeline
                      bool                    m_bIsMVC; // enables MVC mode (need to support several files as an output)
                      bool                    m_bIsExtBuffers; // indicates if external buffers were allocated
                      bool                    m_bIsVideoWall; // indicates special mode: decoding will be done in a loop
                      bool                    m_bIsCompleteFrame;
                      mfxU32                  m_fourcc; // color format of vpp out, i420 by default
                      bool                    m_bPrintLatency;
                      bool                    m_bOutI420;

                      mfxU16                  m_vppOutWidth;
                      mfxU16                  m_vppOutHeight;

                      mfxU32                  m_nTimeout; // enables timeout for video playback, measured in seconds
                      mfxU16                  m_nMaxFps; // limit of fps, if isn't specified equal 0.
                      mfxU32                  m_nFrames; //limit number of output frames

                      mfxU16                  m_diMode;
                      bool                    m_bVppIsUsed;
                      bool                    m_bVppFullColorRange;
                      std::vector&ltmsdk_tick&gt  m_vLatency;

                      msdk_tick               m_startTick;
                      msdk_tick               m_delayTicks;

                      mfxExtVPPDoNotUse       m_VppDoNotUse;      // for disabling VPP algorithms
                      mfxExtVPPDeinterlacing  m_VppDeinterlacing;
                      std::vector&ltmfxExtBuffer*&gt m_VppExtParams;

                      mfxExtVPPVideoSignalInfo m_VppVideoSignalInfo;
                      std::vector&ltmfxExtBuffer*&gt m_VppSurfaceExtParams;

                      CHWDevice               *m_hwdev;
                    #if D3D_SURFACES_SUPPORT
                      IGFXS3DControl          *m_pS3DControl;

                      CDecodeD3DRender         m_d3dRender;
                    #endif

                      bool                    m_bRenderWin;
                      mfxU32                  m_nRenderWinX;
                      mfxU32                  m_nRenderWinY;
                      mfxU32                  m_nRenderWinW;
                      mfxU32                  m_nRenderWinH;

                      mfxU32                  m_export_mode;
                      mfxI32                  m_monitorType;
                    #if defined(LIBVA_SUPPORT)
                      mfxI32                  m_libvaBackend;
                      bool                    m_bPerfMode;
                    #endif // defined(MFX_LIBVA_SUPPORT)

                      bool                    m_bResetFileWriter;
                      bool                    m_bResetFileReader;
                    private:
                      CDecodingPipeline(const CDecodingPipeline&);
                      void operator=(const CDecodingPipeline&);
                    };

                    #endif // __PIPELINE_DECODE_H__
                  </ui-codemirror>
                </div>
            </div>
        </div>
    </div>

    <div class="row">
        <div class="col-lg-12">
            <div ibox title="Create sample_decode.cpp file with the following code: ">
                <div content-block name="xdk-issues" message="Check after completing this section">
                  <ui-codemirror ui-codemirror-opts="editorOptions" id="topic-configure">

                    #include "mfx_samples_config.h"

                    #include "pipeline_decode.h"
                    #include &ltsstream&gt

                    void PrintHelp(msdk_char *strAppName, const msdk_char *strErrorMessage)
                    {
                      msdk_printf(MSDK_STRING("Decoding Sample Version %s\n\n"), MSDK_SAMPLE_VERSION);

                      if (strErrorMessage)
                      {
                          msdk_printf(MSDK_STRING("Error: %s\n"), strErrorMessage);
                      }

                      msdk_printf(MSDK_STRING("Usage: %s &ltcodecid&gt [&ltoptions&gt] -i InputBitstream\n"), strAppName);
                      msdk_printf(MSDK_STRING("   or: %s &ltcodecid&gt [&ltoptions&gt] -i InputBitstream -r\n"), strAppName);
                      msdk_printf(MSDK_STRING("   or: %s &ltcodecid&gt [&ltoptions&gt] -i InputBitstream -o OutputYUVFile\n"), strAppName);
                      msdk_printf(MSDK_STRING("\n"));
                      msdk_printf(MSDK_STRING("Supported codecs (&ltcodecid&gt):\n"));
                      msdk_printf(MSDK_STRING("   &ltcodecid&gt=h264|mpeg2|vc1|mvc|jpeg - built-in Media SDK codecs\n"));
                      msdk_printf(MSDK_STRING("   &ltcodecid&gt=h265|capture            - in-box Media SDK plugins (may require separate downloading and installation)\n"));
                      msdk_printf(MSDK_STRING("\n"));
                      msdk_printf(MSDK_STRING("Work models:\n"));
                      msdk_printf(MSDK_STRING("  1. Performance model: decoding on MAX speed, no rendering, no YUV dumping (no -r or -o option)\n"));
                      msdk_printf(MSDK_STRING("  2. Rendering model: decoding with rendering on the screen (-r option)\n"));
                      msdk_printf(MSDK_STRING("  3. Dump model: decoding with YUV dumping (-o option)\n"));
                      msdk_printf(MSDK_STRING("\n"));
                      msdk_printf(MSDK_STRING("Options:\n"));
                      msdk_printf(MSDK_STRING("   [-hw]                     - use platform specific SDK implementation (default)\n"));
                      msdk_printf(MSDK_STRING("   [-sw]                     - use software implementation, if not specified platform specific SDK implementation is used\n"));
                      msdk_printf(MSDK_STRING("   [-p guid]                 - 32-character hexadecimal guid string\n"));
                      msdk_printf(MSDK_STRING("   [-path path]              - path to plugin (valid only in pair with -p option)\n"));
                      msdk_printf(MSDK_STRING("                               (optional for Media SDK in-box plugins, required for user-decoder ones)\n"));
                      msdk_printf(MSDK_STRING("   [-f]                      - rendering framerate\n"));
                      msdk_printf(MSDK_STRING("   [-w]                      - output width\n"));
                      msdk_printf(MSDK_STRING("   [-h]                      - output height\n"));
                      msdk_printf(MSDK_STRING("   [-di bob/adi]             - enable deinterlacing BOB/ADI\n"));
                      msdk_printf(MSDK_STRING("\n"));
                      msdk_printf(MSDK_STRING("JPEG Chroma Type:\n"));
                      msdk_printf(MSDK_STRING("   [-jpeg_rgb] - RGB Chroma Type\n"));
                      msdk_printf(MSDK_STRING("Output format parameters:\n"));
                      msdk_printf(MSDK_STRING("   [-i420] - pipeline output format: NV12, output file format: I420\n"));
                      msdk_printf(MSDK_STRING("   [-nv12] - pipeline output format: NV12, output file format: NV12\n"));
                      msdk_printf(MSDK_STRING("   [-rgb4] - pipeline output format: RGB4, output file format: RGB4\n"));
                      msdk_printf(MSDK_STRING("   [-rgb4_fcr] - pipeline output format: RGB4 in full color range, output file format: RGB4 in full color range\n"));
                      msdk_printf(MSDK_STRING("   [-p010] - pipeline output format: P010, output file format: P010\n"));
                      msdk_printf(MSDK_STRING("   [-a2rgb10] - pipeline output format: A2RGB10, output file format: A2RGB10\n"));
                      msdk_printf(MSDK_STRING("\n"));
                    #if D3D_SURFACES_SUPPORT
                      msdk_printf(MSDK_STRING("   [-d3d]                    - work with d3d9 surfaces\n"));
                      msdk_printf(MSDK_STRING("   [-d3d11]                  - work with d3d11 surfaces\n"));
                      msdk_printf(MSDK_STRING("   [-r]                      - render decoded data in a separate window \n"));
                      msdk_printf(MSDK_STRING("   [-wall w h n m t tmo]     - same as -r, and positioned rendering window in a particular cell on specific monitor \n"));
                      msdk_printf(MSDK_STRING("       w                     - number of columns of video windows on selected monitor\n"));
                      msdk_printf(MSDK_STRING("       h                     - number of rows of video windows on selected monitor\n"));
                      msdk_printf(MSDK_STRING("       n(0,.,w*h-1)          - order of video window in table that will be rendered\n"));
                      msdk_printf(MSDK_STRING("       m(0,1..)              - monitor id \n"));
                      msdk_printf(MSDK_STRING("       t(0/1)                - enable/disable window's title\n"));
                      msdk_printf(MSDK_STRING("       tmo                   - timeout for -wall option\n"));
                      msdk_printf(MSDK_STRING("Screen capture parameters:\n"));
                      msdk_printf(MSDK_STRING("   [-scr:w]                  - screen resolution width\n"));
                      msdk_printf(MSDK_STRING("   [-scr:h]                  - screen resolution height\n"));
                      msdk_printf(MSDK_STRING("\n"));

                    #endif
                    #if defined(LIBVA_SUPPORT)
                      msdk_printf(MSDK_STRING("   [-vaapi]                  - work with vaapi surfaces\n"));
                    #endif
                    #if defined(LIBVA_X11_SUPPORT)
                      msdk_printf(MSDK_STRING("   [-r]                      - render decoded data in a separate X11 window \n"));
                    #endif
                    #if defined(LIBVA_WAYLAND_SUPPORT)
                      msdk_printf(MSDK_STRING("   [-rwld]                   - render decoded data in a Wayland window \n"));
                      msdk_printf(MSDK_STRING("   [-perf]                   - turn on asynchronous flipping for Wayland rendering \n"));
                    #endif
                    #if defined(LIBVA_DRM_SUPPORT)
                      msdk_printf(MSDK_STRING("   [-rdrm]                   - render decoded data in a thru DRM frame buffer\n"));
                      msdk_printf(MSDK_STRING("   [-window x y w h]         - set render window position and size\n"));
                    #endif
                      msdk_printf(MSDK_STRING("   [-low_latency]            - configures decoder for low latency mode (supported only for H.264 and JPEG codec)\n"));
                      msdk_printf(MSDK_STRING("   [-calc_latency]           - calculates latency during decoding and prints log (supported only for H.264 and JPEG codec)\n"));
                      msdk_printf(MSDK_STRING("   [-async]                  - depth of asynchronous pipeline. default value is 4. must be between 1 and 20\n"));
                      msdk_printf(MSDK_STRING("   [-gpucopy::&lton,off&gt] Enable or disable GPU copy mode\n"));
                      msdk_printf(MSDK_STRING("   [-timeout]                - timeout in seconds\n"));
                    #if !defined(_WIN32) && !defined(_WIN64)
                      msdk_printf(MSDK_STRING("   [-threads_num]            - number of mediasdk task threads\n"));
                      msdk_printf(MSDK_STRING("   [-threads_schedtype]      - scheduling type of mediasdk task threads\n"));
                      msdk_printf(MSDK_STRING("   [-threads_priority]       - priority of mediasdk task threads\n"));
                      msdk_printf(MSDK_STRING("\n"));
                      msdk_thread_printf_scheduling_help();
                    #endif
                    #if defined(_WIN32) || defined(_WIN64)
                      msdk_printf(MSDK_STRING("   [-jpeg_rotate n]          - rotate jpeg frame n degrees \n"));
                      msdk_printf(MSDK_STRING("       n(90,180,270)         - number of degrees \n"));

                      msdk_printf(MSDK_STRING("\nFeatures: \n"));
                      msdk_printf(MSDK_STRING("   Press 1 to toggle fullscreen rendering on/off\n"));
                    #endif
                      msdk_printf(MSDK_STRING("\n"));
                      msdk_printf(MSDK_STRING("Example:\n"));
                      msdk_printf(MSDK_STRING("  %s h265 -i in.bit -o out.yuv -p 15dd936825ad475ea34e35f3f54217a6\n"), strAppName);
                    }

                  </ui-codemirror>
                </br>

                  <ui-codemirror ui-codemirror-opts="editorOptions" id="topic-configure">
                    mfxStatus ParseInputString(msdk_char* strInput[], mfxU8 nArgNum, sInputParams* pParams)
                    {
                      if (1 == nArgNum)
                      {
                          PrintHelp(strInput[0], NULL);
                          return MFX_ERR_UNSUPPORTED;
                      }

                      MSDK_CHECK_POINTER(pParams, MFX_ERR_NULL_PTR);

                      // set default implementation
                      pParams->bUseHWLib = true;
                      pParams->bUseFullColorRange = false;
                    #if defined(LIBVA_SUPPORT)
                      pParams->libvaBackend = MFX_LIBVA_DRM;
                    #endif

                      for (mfxU8 i = 1; i &lt nArgNum; i++)
                      {
                          if (MSDK_CHAR('-') != strInput[i][0])
                          {
                              mfxStatus sts = StrFormatToCodecFormatFourCC(strInput[i], pParams->videoType);
                              if (sts != MFX_ERR_NONE)
                              {
                                  PrintHelp(strInput[0], MSDK_STRING("Unknown codec"));
                                  return MFX_ERR_UNSUPPORTED;
                              }
                              if (!IsDecodeCodecSupported(pParams->videoType))
                              {
                                  PrintHelp(strInput[0], MSDK_STRING("Unsupported codec"));
                                  return MFX_ERR_UNSUPPORTED;
                              }
                              if (pParams->videoType == CODEC_MVC)
                              {
                                  pParams->videoType = MFX_CODEC_AVC;
                                  pParams->bIsMVC = true;
                              }
                              continue;
                          }

                          if (0 == msdk_strcmp(strInput[i], MSDK_STRING("-sw")))
                          {
                              pParams->bUseHWLib = false;
                          }
                          else if (0 == msdk_strcmp(strInput[i], MSDK_STRING("-hw")))
                          {
                              pParams->bUseHWLib = true;
                          }
                    #if D3D_SURFACES_SUPPORT
                          else if (0 == msdk_strcmp(strInput[i], MSDK_STRING("-d3d")))
                          {
                              pParams->memType = D3D9_MEMORY;
                          }
                          else if (0 == msdk_strcmp(strInput[i], MSDK_STRING("-d3d11")))
                          {
                              pParams->memType = D3D11_MEMORY;
                          }
                          else if (0 == msdk_strcmp(strInput[i], MSDK_STRING("-r")))
                          {
                              pParams->mode = MODE_RENDERING;
                              // use d3d9 rendering by default
                              if (SYSTEM_MEMORY == pParams->memType)
                                  pParams->memType = D3D9_MEMORY;
                          }
                          else if (0 == msdk_strcmp(strInput[i], MSDK_STRING("-wall")))
                          {
                              if(i + 6 &gt= nArgNum)
                              {
                                  PrintHelp(strInput[0], MSDK_STRING("Not enough parameters for -wall key"));
                                  return MFX_ERR_UNSUPPORTED;
                              }
                              // use d3d9 rendering by default
                              if (SYSTEM_MEMORY == pParams->memType)
                                  pParams->memType = D3D9_MEMORY;

                              pParams->mode = MODE_RENDERING;

                              msdk_opt_read(strInput[++i], pParams->nWallW);
                              msdk_opt_read(strInput[++i], pParams->nWallH);
                              msdk_opt_read(strInput[++i], pParams->nWallCell);
                              msdk_opt_read(strInput[++i], pParams->nWallMonitor);

                              mfxU32 nTitle;
                              msdk_opt_read(strInput[++i], nTitle);

                              pParams->bWallNoTitle = 0 == nTitle;

                              msdk_opt_read(strInput[++i], pParams->nTimeout);
                          }
                    #endif
                    #if defined(LIBVA_SUPPORT)
                          else if (0 == msdk_strcmp(strInput[i], MSDK_STRING("-vaapi")))
                          {
                              pParams->memType = D3D9_MEMORY;
                          }
                          else if (0 == msdk_strcmp(strInput[i], MSDK_STRING("-r")))
                          {
                              pParams->memType = D3D9_MEMORY;
                              pParams->mode = MODE_RENDERING;
                              pParams->libvaBackend = MFX_LIBVA_X11;
                          }
                          else if (0 == msdk_strcmp(strInput[i], MSDK_STRING("-rwld")))
                          {
                              pParams->memType = D3D9_MEMORY;
                              pParams->mode = MODE_RENDERING;
                              pParams->libvaBackend = MFX_LIBVA_WAYLAND;
                          }
                          else if (0 == msdk_strcmp(strInput[i], MSDK_STRING("-perf")))
                          {
                              pParams->bPerfMode = true;
                          }
                          else if (0 == msdk_strncmp(strInput[i], MSDK_STRING("-rdrm"), 5))
                          {
                              pParams->memType = D3D9_MEMORY;
                              pParams->mode = MODE_RENDERING;
                              pParams->libvaBackend = MFX_LIBVA_DRM_MODESET;
                              if (strInput[i][5]) {
                                  if (strInput[i][5] != '-') {
                                      PrintHelp(strInput[0], MSDK_STRING("unsupported monitor type"));
                                      return MFX_ERR_UNSUPPORTED;
                                  }
                                  pParams->monitorType = getMonitorType(&strInput[i][6]);
                                  if (pParams->monitorType &gt= MFX_MONITOR_MAXNUMBER) {
                                      PrintHelp(strInput[0], MSDK_STRING("unsupported monitor type"));
                                      return MFX_ERR_UNSUPPORTED;
                                  }
                              } else {
                                  pParams->monitorType = MFX_MONITOR_AUTO; // that's case of "-rdrm" pure option
                              }
                          }
                          else if (0 == msdk_strcmp(strInput[i], MSDK_STRING("-window")))
                          {
                              if(i +4 &gt= nArgNum)
                              {
                                  PrintHelp(strInput[0], MSDK_STRING("Not enough parameters for -window key"));
                                  return MFX_ERR_UNSUPPORTED;
                              }
                              msdk_opt_read(strInput[++i], pParams->nRenderWinX);
                              msdk_opt_read(strInput[++i], pParams->nRenderWinY);
                              msdk_opt_read(strInput[++i], pParams->Width);
                              msdk_opt_read(strInput[++i], pParams->Height);

                              if (0 == pParams->Width)
                                  pParams->Width = 320;
                              if (0 == pParams->Height)
                                  pParams->Height = 240;

                              pParams->bRenderWin = true;
                          }
                    #endif
                          else if (0 == msdk_strcmp(strInput[i], MSDK_STRING("-low_latency")))
                          {
                              switch (pParams->videoType)
                              {
                                  case MFX_CODEC_HEVC:
                                  case MFX_CODEC_AVC:
                                  case MFX_CODEC_JPEG:
                                  {
                                      pParams->bLowLat = true;
                                      if (!pParams->bIsMVC)
                                          break;
                                  }
                                  default:
                                  {
                                       PrintHelp(strInput[0], MSDK_STRING("-low_latency mode is suppoted only for H.264 and JPEG codecs"));
                                       return MFX_ERR_UNSUPPORTED;
                                  }
                              }
                          }
                          else if (0 == msdk_strcmp(strInput[i], MSDK_STRING("-jpeg_rotate")))
                          {
                              if(MFX_CODEC_JPEG != pParams->videoType)
                                  return MFX_ERR_UNSUPPORTED;

                              if(i + 1 &gt= nArgNum)
                              {
                                  PrintHelp(strInput[0], MSDK_STRING("Not enough parameters for -jpeg_rotate key"));
                                  return MFX_ERR_UNSUPPORTED;
                              }

                              msdk_opt_read(strInput[++i], pParams->nRotation);
                              if((pParams->nRotation != 90)&&(pParams->nRotation != 180)&&(pParams->nRotation != 270))
                              {
                                  PrintHelp(strInput[0], MSDK_STRING("-jpeg_rotate is supported only for 90, 180 and 270 angles"));
                                  return MFX_ERR_UNSUPPORTED;
                              }
                          }
                          else if (0 == msdk_strcmp(strInput[i], MSDK_STRING("-calc_latency")))
                          {
                              switch (pParams->videoType)
                              {
                                  case MFX_CODEC_HEVC:
                                  case MFX_CODEC_AVC:
                                  case MFX_CODEC_JPEG:
                                  {
                                      pParams->bCalLat = true;
                                      if (!pParams->bIsMVC)
                                          break;
                                  }
                                  default:
                                  {
                                       PrintHelp(strInput[0], MSDK_STRING("-calc_latency mode is suppoted only for H.264 and JPEG codecs"));
                                       return MFX_ERR_UNSUPPORTED;
                                  }
                              }
                          }
                          else if (0 == msdk_strcmp(strInput[i], MSDK_STRING("-async")))
                          {
                              if(i + 1 &gt= nArgNum)
                              {
                                  PrintHelp(strInput[0], MSDK_STRING("Not enough parameters for -async key"));
                                  return MFX_ERR_UNSUPPORTED;
                              }
                              if (MFX_ERR_NONE != msdk_opt_read(strInput[++i], pParams->nAsyncDepth))
                              {
                                  PrintHelp(strInput[0], MSDK_STRING("async is invalid"));
                                  return MFX_ERR_UNSUPPORTED;
                              }
                          }
                          else if (0 == msdk_strcmp(strInput[i], MSDK_STRING("-timeout")))
                          {
                              if(i + 1 &gt= nArgNum)
                              {
                                  PrintHelp(strInput[0], MSDK_STRING("Not enough parameters for -timeout key"));
                                  return MFX_ERR_UNSUPPORTED;
                              }
                              if (MFX_ERR_NONE != msdk_opt_read(strInput[++i], pParams->nTimeout))
                              {
                                  PrintHelp(strInput[0], MSDK_STRING("timeout is invalid"));
                                  return MFX_ERR_UNSUPPORTED;
                              }
                          }

                          else if (0 == msdk_strcmp(strInput[i], MSDK_STRING("-di")))
                          {
                              if(i + 1 &gt= nArgNum)
                              {
                                  PrintHelp(strInput[0], MSDK_STRING("Not enough parameters for -di key"));
                                  return MFX_ERR_UNSUPPORTED;
                              }
                              msdk_char diMode[4] = {};
                              if (MFX_ERR_NONE != msdk_opt_read(strInput[++i], diMode))
                              {
                                  PrintHelp(strInput[0], MSDK_STRING("deinterlace value is not set"));
                                  return MFX_ERR_UNSUPPORTED;
                              }

                              if (0 == msdk_strcmp(diMode, MSDK_CHAR("bob")))
                              {
                                  pParams->eDeinterlace = MFX_DEINTERLACING_BOB;
                              }
                              else if (0 == msdk_strcmp(diMode, MSDK_CHAR("adi")))
                              {
                                  pParams->eDeinterlace = MFX_DEINTERLACING_ADVANCED;
                              }
                              else
                              {
                                  PrintHelp(strInput[0], MSDK_STRING("deinterlace value is invalid"));
                                  return MFX_ERR_UNSUPPORTED;
                              }
                          }
                          else if (0 == msdk_strcmp(strInput[i], MSDK_STRING("-gpucopy::on")))
                          {
                              pParams->gpuCopy = MFX_GPUCOPY_ON;
                          }
                          else if (0 == msdk_strcmp(strInput[i], MSDK_STRING("-gpucopy::off")))
                          {
                              pParams->gpuCopy = MFX_GPUCOPY_OFF;
                          }
                    #if !defined(_WIN32) && !defined(_WIN64)
                          else if (0 == msdk_strcmp(strInput[i], MSDK_STRING("-threads_num")))
                          {
                              if(i + 1 &gt= nArgNum)
                              {
                                  PrintHelp(strInput[0], MSDK_STRING("Not enough parameters for -threads_num key"));
                                  return MFX_ERR_UNSUPPORTED;
                              }
                              if (MFX_ERR_NONE != msdk_opt_read(strInput[++i], pParams->nThreadsNum))
                              {
                                  PrintHelp(strInput[0], MSDK_STRING("threads_num is invalid"));
                                  return MFX_ERR_UNSUPPORTED;
                              }
                          }
                          else if (0 == msdk_strcmp(strInput[i], MSDK_STRING("-threads_schedtype")))
                          {
                              if(i + 1 &gt= nArgNum)
                              {
                                  PrintHelp(strInput[0], MSDK_STRING("Not enough parameters for -threads_schedtype key"));
                                  return MFX_ERR_UNSUPPORTED;
                              }
                              if (MFX_ERR_NONE != msdk_thread_get_schedtype(strInput[++i], pParams->SchedulingType))
                              {
                                  PrintHelp(strInput[0], MSDK_STRING("threads_schedtype is invalid"));
                                  return MFX_ERR_UNSUPPORTED;
                              }
                          }
                          else if (0 == msdk_strcmp(strInput[i], MSDK_STRING("-threads_priority")))
                          {
                              if(i + 1 &gt= nArgNum)
                              {
                                  PrintHelp(strInput[0], MSDK_STRING("Not enough parameters for -threads_priority key"));
                                  return MFX_ERR_UNSUPPORTED;
                              }
                              if (MFX_ERR_NONE != msdk_opt_read(strInput[++i], pParams->Priority))
                              {
                                  PrintHelp(strInput[0], MSDK_STRING("threads_priority is invalid"));
                                  return MFX_ERR_UNSUPPORTED;
                              }
                          }
                    #endif // #if !defined(_WIN32) && !defined(_WIN64)
                          else if (0 == msdk_strcmp(strInput[i], MSDK_STRING("-f")))
                          {
                              if(i + 1 &gt= nArgNum)
                              {
                                  PrintHelp(strInput[0], MSDK_STRING("Not enough parameters for -f key"));
                                  return MFX_ERR_UNSUPPORTED;
                              }
                              if (MFX_ERR_NONE != msdk_opt_read(strInput[++i], pParams->nMaxFPS))
                              {
                                  PrintHelp(strInput[0], MSDK_STRING("rendering frame rate is invalid"));
                                  return MFX_ERR_UNSUPPORTED;
                              }
                          }
                          else if (0 == msdk_strcmp(strInput[i], MSDK_STRING("-scr:w")))
                          {
                              if (i + 1 &lt= nArgNum)
                              {
                                  PrintHelp(strInput[0], MSDK_STRING("Not enough parameters for -scr:w key"));
                                  return MFX_ERR_UNSUPPORTED;
                              }
                              if (MFX_ERR_NONE != msdk_opt_read(strInput[++i], pParams->scrWidth))
                              {
                                  PrintHelp(strInput[0], MSDK_STRING("screen width rate is invalid"));
                                  return MFX_ERR_UNSUPPORTED;
                              }
                          }
                          else if (0 == msdk_strcmp(strInput[i], MSDK_STRING("-scr:h")))
                          {
                              if (i + 1 &lt= nArgNum)
                              {
                                  PrintHelp(strInput[0], MSDK_STRING("Not enough parameters for -scr:h key"));
                                  return MFX_ERR_UNSUPPORTED;
                              }
                              if (MFX_ERR_NONE != msdk_opt_read(strInput[++i], pParams->scrHeight))
                              {
                                  PrintHelp(strInput[0], MSDK_STRING("screen height is invalid"));
                                  return MFX_ERR_UNSUPPORTED;
                              }
                          }
                          else if (0 == msdk_strcmp(strInput[i], MSDK_STRING("-w")))
                          {
                              if (i + 1 &lt= nArgNum)
                              {
                                  PrintHelp(strInput[0], MSDK_STRING("Not enough parameters for -w key"));
                                  return MFX_ERR_UNSUPPORTED;
                              }
                              if (MFX_ERR_NONE != msdk_opt_read(strInput[++i], pParams->Width))
                              {
                                  PrintHelp(strInput[0], MSDK_STRING("width is invalid"));
                                  return MFX_ERR_UNSUPPORTED;
                              }
                          }
                          else if (0 == msdk_strcmp(strInput[i], MSDK_STRING("-h")))
                          {
                              if (i + 1 &lt= nArgNum)
                              {
                                  PrintHelp(strInput[0], MSDK_STRING("Not enough parameters for -h key"));
                                  return MFX_ERR_UNSUPPORTED;
                              }
                              if (MFX_ERR_NONE != msdk_opt_read(strInput[++i], pParams->Height))
                              {
                                  PrintHelp(strInput[0], MSDK_STRING("height is invalid"));
                                  return MFX_ERR_UNSUPPORTED;
                              }
                          }
                          else if (0 == msdk_strcmp(strInput[i], MSDK_STRING("-n")))
                          {
                              if(i + 1 &lt= nArgNum)
                              {
                                  PrintHelp(strInput[0], MSDK_STRING("Not enough parameters for -n key"));
                                  return MFX_ERR_UNSUPPORTED;
                              }
                              if (MFX_ERR_NONE != msdk_opt_read(strInput[++i], pParams->nFrames))
                              {
                                  PrintHelp(strInput[0], MSDK_STRING("rendering frame rate is invalid"));
                                  return MFX_ERR_UNSUPPORTED;
                              }
                          }
                          else if (0 == msdk_strcmp(strInput[i], MSDK_STRING("-jpeg_rgb")))
                          {
                              if(MFX_CODEC_JPEG == pParams->videoType)
                              {
                                 pParams->chromaType = MFX_JPEG_COLORFORMAT_RGB;
                              }
                          }
                          else if (0 == msdk_strcmp(strInput[i], MSDK_STRING("-i420")))
                          {
                              pParams->fourcc = MFX_FOURCC_NV12;
                              pParams->outI420 = true;
                          }
                          else if (0 == msdk_strcmp(strInput[i], MSDK_STRING("-nv12")))
                          {
                              pParams->fourcc = MFX_FOURCC_NV12;
                          }
                          else if (0 == msdk_strcmp(strInput[i], MSDK_STRING("-rgb4")))
                          {
                              pParams->fourcc = MFX_FOURCC_RGB4;
                          }
                          else if (0 == msdk_strcmp(strInput[i], MSDK_STRING("-rgb4_fcr")))
                          {
                              pParams->fourcc = MFX_FOURCC_RGB4;
                              pParams->bUseFullColorRange = true;
                          }
                          else if (0 == msdk_strcmp(strInput[i], MSDK_STRING("-p010")))
                          {
                              pParams->fourcc = MFX_FOURCC_P010;
                          }
                          else if (0 == msdk_strcmp(strInput[i], MSDK_STRING("-a2rgb10")))
                          {
                              pParams->fourcc = MFX_FOURCC_A2RGB10;
                          }
                          else if (0 == msdk_strcmp(strInput[i], MSDK_STRING("-path")))
                          {
                              i++;
                    #if defined(_WIN32) || defined(_WIN64)
                              msdk_char wchar[MSDK_MAX_FILENAME_LEN];
                              msdk_opt_read(strInput[i], wchar);
                              std::wstring wstr(wchar);
                              std::string str(wstr.begin(), wstr.end());

                              strcpy_s(pParams->pluginParams.strPluginPath, str.c_str());
                    #else
                              msdk_opt_read(strInput[i], pParams->pluginParams.strPluginPath);
                    #endif
                              pParams->pluginParams.type = MFX_PLUGINLOAD_TYPE_FILE;
                          }
                          else if (0 == msdk_strcmp(strInput[i], MSDK_STRING("-i:null")))
                          {
                              ;
                          }
                          else // 1-character options
                          {
                              switch (strInput[i][1])
                              {
                              case MSDK_CHAR('p'):
                                  if (++i &lt nArgNum) {
                                     if (MFX_ERR_NONE == ConvertStringToGuid(strInput[i], pParams->pluginParams.pluginGuid))
                                      {
                                          if(pParams->pluginParams.type != MFX_PLUGINLOAD_TYPE_FILE)
                                          {
                                              pParams->pluginParams.type = MFX_PLUGINLOAD_TYPE_GUID;
                                          }
                                      }
                                      else
                                      {
                                          PrintHelp(strInput[0], MSDK_STRING("Unknown options"));
                                      }
                                   }
                                  else {
                                      msdk_printf(MSDK_STRING("error: option '-p' expects an argument\n"));
                                  }
                                  break;
                              case MSDK_CHAR('i'):
                                  if (++i &lt nArgNum) {
                                      msdk_opt_read(strInput[i], pParams->strSrcFile);
                                  }
                                  else {
                                      msdk_printf(MSDK_STRING("error: option '-i' expects an argument\n"));
                                  }
                                  break;
                              case MSDK_CHAR('o'):
                                  if (++i &lt nArgNum) {
                                      pParams->mode = MODE_FILE_DUMP;
                                      msdk_opt_read(strInput[i], pParams->strDstFile);
                                  }
                                  else {
                                      msdk_printf(MSDK_STRING("error: option '-o' expects an argument\n"));
                                  }
                                  break;
                              case MSDK_CHAR('?'):
                                  PrintHelp(strInput[0], NULL);
                                  return MFX_ERR_UNSUPPORTED;
                              default:
                                  {
                                      std::basic_stringstream&ltmsdk_char&lt stream;
                                      stream &lt&lt MSDK_STRING("Unknown option: ") &lt&lt strInput[i];
                                      PrintHelp(strInput[0], stream.str().c_str());
                                      return MFX_ERR_UNSUPPORTED;
                                  }
                              }
                          }
                      }

                      if (0 == msdk_strlen(pParams->strSrcFile) && MFX_CODEC_CAPTURE != pParams->videoType)
                      {
                          msdk_printf(MSDK_STRING("error: source file name not found"));
                          return MFX_ERR_UNSUPPORTED;
                      }

                      if (MFX_CODEC_CAPTURE == pParams->videoType)
                      {
                          if (!pParams->scrWidth || !pParams->scrHeight)
                          {
                              msdk_printf(MSDK_STRING("error: for screen capture, width and height must be specified manually (-scr:w and -scr:h)"));
                              return MFX_ERR_UNSUPPORTED;
                          }
                      }
                      else if (pParams->scrWidth || pParams->scrHeight)
                      {
                          msdk_printf(MSDK_STRING("error: width and height parameters are supported only by screen capture decoder"));
                          return MFX_ERR_UNSUPPORTED;
                      }

                      if ((pParams->mode == MODE_FILE_DUMP) && (0 == msdk_strlen(pParams->strDstFile)))
                      {
                          msdk_printf(MSDK_STRING("error: destination file name not found"));
                          return MFX_ERR_UNSUPPORTED;
                      }

                      if (MFX_CODEC_MPEG2   != pParams->videoType &&
                          MFX_CODEC_AVC     != pParams->videoType &&
                          MFX_CODEC_HEVC    != pParams->videoType &&
                          MFX_CODEC_VC1     != pParams->videoType &&
                          MFX_CODEC_JPEG    != pParams->videoType &&
                          MFX_CODEC_CAPTURE != pParams->videoType &&
                          MFX_CODEC_VP8     != pParams->videoType &&
                          MFX_CODEC_VP9     != pParams->videoType)
                      {
                          PrintHelp(strInput[0], MSDK_STRING("Unknown codec"));
                          return MFX_ERR_UNSUPPORTED;
                      }

                      if (pParams->nAsyncDepth == 0)
                      {
                          pParams->nAsyncDepth = 4; //set by default;
                      }

                      return MFX_ERR_NONE;
                    }

                    #if defined(_WIN32) || defined(_WIN64)
                    int _tmain(int argc, TCHAR *argv[])
                    #else
                    int main(int argc, char *argv[])
                    #endif
                    {
                      sInputParams        Params;   // input parameters from command line
                      CDecodingPipeline   Pipeline; // pipeline for decoding, includes input file reader, decoder and output file writer

                      mfxStatus sts = MFX_ERR_NONE; // return value check

                      sts = ParseInputString(argv, (mfxU8)argc, &Params);
                      MSDK_CHECK_PARSE_RESULT(sts, MFX_ERR_NONE, 1);

                      if (Params.bIsMVC)
                          Pipeline.SetMultiView();

                      sts = Pipeline.Init(&Params);
                      MSDK_CHECK_STATUS(sts, "Pipeline.Init failed");

                      // print stream info
                      Pipeline.PrintInfo();

                      msdk_printf(MSDK_STRING("Decoding started\n"));
                    </ui-codemirror>
                  </br>
                    <ui-codemirror ui-codemirror-opts="editorOptions" id="topic-configure">

                      for (;;)
                      {
                          sts = Pipeline.RunDecoding();

                          if (MFX_ERR_INCOMPATIBLE_VIDEO_PARAM == sts || MFX_ERR_DEVICE_LOST == sts || MFX_ERR_DEVICE_FAILED == sts)
                          {
                              if (MFX_ERR_INCOMPATIBLE_VIDEO_PARAM == sts)
                              {
                                  msdk_printf(MSDK_STRING("\nERROR: Incompatible video parameters detected. Recovering...\n"));
                              }
                              else
                              {
                                  msdk_printf(MSDK_STRING("\nERROR: Hardware device was lost or returned unexpected error. Recovering...\n"));
                                  sts = Pipeline.ResetDevice();
                                  MSDK_CHECK_STATUS(sts, "Pipeline.ResetDevice failed");
                              }

                              sts = Pipeline.ResetDecoder(&Params);
                              MSDK_CHECK_STATUS(sts, "Pipeline.ResetDecoder failed");
                              continue;
                          }
                          else
                          {
                              MSDK_CHECK_STATUS(sts, "Pipeline.RunDecoding failed");
                              break;
                          }
                      }

                      msdk_printf(MSDK_STRING("\nDecoding finished\n"));

                      return 0;
                    }

                  </ui-codemirror>
                </div>
            </div>
        </div>
    </div>



</div>
